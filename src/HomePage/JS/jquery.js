/ *! jQuery v3.4.1 | (c) Quỹ JS và các cộng tác viên khác | jquery.org/license * /
! function (e, t) {"userict"; "object" == typeof module && "object" == typeof module.exports? module.exports = e.document? t (e ,! 0): function (e) {if (! e.document) đưa ra Lỗi mới ("jQuery yêu cầu một cửa sổ có tài liệu"); return t (e)}: t (e)} ("không xác định"! = windowof? window: this, function ( C, e) {"sử dụng nghiêm ngặt"; var t = [], E = C.document, r = Object.getPrototypeOf, s = t.slice, g = t.concat, u = t.push, i = t. indexOf, n = {}, o = n.toString, v = n.hasOwnProperty, a = v.toString, l = a.call (Object), y = {}, m = function (e) {return "function" == typeof e && "number"! = typeof e.nodeType}, x = function (e) {return null! = e && e === e.window}, c = {type :! 0, src :! 0, nonce: ! 0, noModule :! 0}; hàm b (e, t, n) {var r, i, o = (n = n || E) .createEuity ("script"); if (o.text = e, t) cho (r in c) (i = t [r] || t.getAttribution && t.getAttribution (r)) && o.setAttribution (r, i); n.head.appendChild (o) .parentNode.removeChild (o)} chức năng w (e) {return null == e? e + "": "object" = = typeof e | | "function" == typeof e? n [o.call (e)] || "object": typeof e} var f = "3.4.1", k = function (e, t) {return mới k.fn.init (e, t)}, p = / ^ [\ s \ uFEFF \ xA0] + | [\ s \ uFEFF \ xA0] + $ / g; chức năng d (e) {var t =! ! e && "length" trong e && e.length, n = w (e); return! m (e) &&! x (e) && ("mảng" === n || 0 === t || "number" == typeof t && 0 <t && t-1 in e)} k.fn = k.prototype = {jquery: f, constructor: k, length: 0, toArray: function () {return s.call (this)}, get: function (e) {return null == e? s.call (this): e <0? this [e + this.length]: this [e]}, pushStack: function (e) {var t = k.merge (this.constructor (), e); return t.prevObject = this, t}, Each: function (e) {return k.each (this, e)}, map:function (n) {return this.pushStack (k.map (this, function (e, t) {return n.call (e, t, e)}))}, lát: function () {return this.pushStack ( s.apply (this, argument))}, first: function () {return this.eq (0)}, last: function () {return this.eq (-1)}, eq: function (e) {var t = this.length, n = + e + (e <0? t: 0); return this.pushStack (0 <= n && n <t? [this [n]]: [])}, end: function () { return this.prevObject || this.constructor ()}, push: u, sort: t.sort, splice: t.splice}, k.extend = k.fn.extend = function () {var e, t, n , r, i, o, a = argument [0] || {}, s = 1, u = argument.length, l =! 1; for ("boolean" == typeof a && (l = a, a = argument [s] || {}, s ++), "object" == typeof a || m (a) || (a = {}), s === u && (a = this, s -); s < u; s ++) if (null! = (e = argument [s])) for (t in e) r = e [t], "__ proto __"! == t && a! == r && (l && r && (k.isPlainObject (r ) || (i = Array.isArray (r)))? (n = a [t], o = i &&!Array.isArray (n)? []: I || k.isPlainObject (n)? N: {}, i =! 1, a [t] = k.extend (l, o, r)): void 0! == r && (a [t] = r)); trả về a}, k.extend ({extendo: "jQuery" + (f + Math.random ()). thay thế (/ \ D / g, ""), isReady :! 0, error: function (e) {throw new Error (e)}, noop: function () {}, isPlainObject: function (e) {var t, n; return! (! e || "[object Đối tượng] "! == o.call (e)) && (! (T = r (e)) ||" function "== typeof (n = v.call (t," constructor ") && t.constructor) && a .call (n) === l)}, isEmptyObject: function (e) {var t; for (t in e) return! 1; return! 0}, globalEval: function (e, t) {b (e, {nonce: t && t.nonce})}, mỗi: hàm (e, t) {var n, r = 0; if (d (e)) {for (n = e.length; r <n; r ++) if ( ! 1 === t.call (e [r], r, e [r])) break} khác cho (r in e) if (! 1 === t.call (e [r], r, e [r])) break; return e}, trim: function (e) {return null == e? "" :( e + ""). thay thế (p, "")},makeArray: function (e, t) {var n = t || []; return null! = e && (d (Object (e))? k.merge (n, "string" == typeof e? [e]: e): u.call (n, e)), n}, inArray: function (e, t, n) {return null == t? -1: i.call (t, e, n)}, hợp nhất: hàm (e, t) {for (var n = + t.length, r = 0, i = e.length; r <n; r ++) e [i ++] = t [r]; return e.length = i, e}, grep: function (e, t, n) {for (var r = [], i = 0, o = e.length, a =! n; i <o; i ++)! t (e [i] , i)! == a && r.push (e [i]); return r}, map: function (e, t, n) {var r, i, o = 0, a = []; if (d (e )) for (r = e.length; o <r; o ++) null! = (i = t (e [o], o, n)) && a.push (i); khác cho (o in e) null! = (i = t (e [o], o, n)) && a.push (i); trả lại g.apply ([], a)}, guide: 1, support: y}), "function" == typeof Symbol && (k.fn [Symbol.iterator] = t [Symbol.iterator]), k.each ("Chuỗi số Boolean Mảng ngày Biểu tượng lỗi đối tượng RegExp" .split (""), function (e, t) { n ["[đối tượng" + t + "] "] = t.toLowerCase ()}); var h = function (n) {var e, d, b, o, i, h, f, g, w, u, l, T, C, a, E , v, s, c, y, k = "sizzle" + 1 * Ngày mới, m = n.document, S = 0, r = 0, p = ue (), x = ue (), N = ue ( ), A = ue (), D = function (e, t) {return e === t && (l =! 0), 0}, j = {}. HasOwnProperty, t = [], q = t.pop , L = t.push, H = t.push, O = t.slice, P = function (e, t) {for (var n = 0, r = e.length; n <r; n ++) if (e [n] === t) return n; return-1}, R = "đã kiểm tra | đã chọn | async | tự động lấy nét | tự động phát | điều khiển | defer | bị vô hiệu hóa | ẩn | ismap | loop | nhiều | mở | chỉ đọc | bắt buộc ", M =" [\\ x20 \\ t \\ r \\ n \\ f] ", I =" (?: \\\\. | [\\ w-] | [^ \ 0 - \\ xa0]) + ", W =" \\ ["+ M +" * ("+ I +") (?: "+ M +" * ([* ^ $ |! ~]? =) "+ M +" * (? : '((?: \\\\. | [^ \\\\']) *) '| \ "((?: \\\\. | [^ \\\\"]) *) \ "| (" + I + ")) |)" + M + "* \\]", $ = ":(" + I + ") (?: \\ ((('((?: \\\\. | [^ \\\ '')) *) '| \ "((?: \\\\. | [^ \\\\\"]) *) \ ") | ((?: \\\\. | [^ \\\\ () [\\ ]] | "+ W +") *) |. *) \\) |) ", F = new RegExp (M +" + "," g "), B = new RegExp (" ^ "+ M +" + | ( (?: ^ | [^ \\\\]) (?: \\\\.) *) "+ M +" + $ "," g "), _ = RegExp mới (" ^ "+ M +" *, "+ M +" * "), z = new RegExp (" ^ "+ M +" * ([> + ~] | "+ M +") "+ M +" * "), U = new RegExp (M +" |> " ), X = new RegExp ($), V = new RegExp ("^" + I + "$"), G = {ID: new RegExp ("^ # (" + I + ")"), LỚP: RegExp mới ( "^ \\. (" + I + ")"), TAG: RegExp mới ("^ (" + I + "| [*])"), ATTR: RegExp mới ("^" + W), PSEUDO: RegExp mới ("^" + $), TRẺ: RegExp mới ("^ :( chỉ | đầu tiên | cuối | nth | nth-cuối) - (con | của loại) (?: \\ (" + M + "* (thậm chí | lẻ | (([+ -] |) (\\ d *) n |) "+ M +" * (?:([+ -] |) "+ M +" * (\\ d +) |)) "+ M +" * \\) |) "," i "), bool: RegExp mới (" ^ (?: "+ R + ") $", "i"), nhu cầu Nội dung: RegExp mới ("^" + M + "* [> + ~] |: (chẵn | lẻ | eq | gt | lt | nth | đầu tiên | cuối) (?: \ \ ("+ M +" * ((?: - \\ d)? \\ d *) "+ M +" * \\) |) (? = [^ -] | $) "," i ")}, Y = / HTML $ / i, Q = / ^ (?: Đầu vào | chọn | textarea | nút) $ / i, J = / ^ h \ d $ / i, K = / ^ [^ {] + \ {\ s * \ [bản địa \ w /, Z = / ^ (?: # ([\ w -] +) | (\ w +) | \. ([\ w -] +)) $ /, ee = / [+ ~] /, te = new RegExp ("\\\\ ([\\ da-f] {1,6}" + M + "? | (" + M + ") |.)", "ig"), ne = function (e, t, n) {var r = "0x" + t-65536; return r! = r || n? t: r <0? String.fromCharCode (r + 65536): String.fromCharCode (r >> 10 | 55296,1023 & r | 56320)}, re = / ([\ 0- \ x1f \ x7f] | ^ -? \ D) | ^ - $ | [^ \ 0- \ x1f \ x7f- \ uFFFF \ w -] / g, tức là = hàm (e, t) {return t? "\ 0" === e? "\ ufffd": e.slice (0, -1) + "\\ "+ e.charCodeAt (e.length-1) .toString (16) +" ":" \\ "+ e}, oe = function () {T ()}, ae = be (function (e) {return! 0 === e.disables && "fieldset" === e.nodeName.toLowerCase ()}, {dir: "ParentNode", next: "huyền thoại"}); hãy thử {H.apply (t = O. gọi (m.childNodes), m.childNodes), t [m.childNodes.length] .nodeType} Catch (e) {H = {áp dụng: t.length? function (e, t) {L.apply (e, O.call (t))}: function (e, t) {var n = e.length, r = 0; while (e [n ++] = t [r ++]); e.length = n-1}}} hàm se (t, e, n, r) {var i, o, a, s, u, l, c, f = e && e.ownerDocument, p = e? e.nodeType: 9; if (n = n || [], "chuỗi"! = typeof t ||! t || 1! == p && 9! == p && 11! == p) return n; if (! r && ((e? e.ownerDocument || e: m) ! == C && T (e), e = e | | C, E)) {if (11! == p && (u = Z.exec (t))) if (i = u [1]) {if (9 === p) {if (! (A = e.getEuityById (i))) return n; if (a.id === i) return n.push (a), n} khác if (f && (a = f.getEuityById (i)) && y (e, a) && a.id === i) return n.push (a), n} khác {if (u [2]) return H.apply (n, e.getElementsByTagName (t )), n; if ((i = u [3]) && d.getElementsByClassName && e.getElementsByClassName) trả về H.apply (n, e.getElementsByClassName (i)), n} if (d.qsa &! " && (! v ||! v.test (t)) && (1! == p || "đối tượng"! == e.nodeName.toLowerCase ())) {if (c = t, f = e, 1 === p && U.test (t)) {(s = e.getAttribution ("id"))? S = s.replace (re, tức là): e.setAttribution ("id", s = k), o = (l = h (t)). chiều dài; while (o -) l [o] = "#" + s + "" + xe (l [o]); c = l.join (","), f = ee.test (t) && ye (e.parentNode) || e} thử {return H.apply (n, f.querySelector ALL (c)), n} Catch (e) {A (t ,! 0)} cuối cùng {s === k && e.removeAttribution ("id")}}} return g (t.replace (B, "$ 1"), e, n, r)} hàm ue () {var r = [];Hàm trả về e (t, n) {return r.push (t + "")> b.cacheLpm && xóa e [r.shift ()], e [t + ""] = n}} chức năng le (e) {return e [ k] =! 0, e} chức năng ce (e) {var t = C.createEuity ("fieldset"); thử {return !! e (t)} Catch (e) {return! 1} cuối cùng {t.parentNode && t .parentNode.removeChild (t), t = null}} chức năng fe (e, t) {var n = e.split ("|"), r = n.length; while (r -) b.attrHandle [n [r]] = t} chức năng pe (e, t) {var n = t && e, r = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex-t.source Index; if (r) return r; if (n) while (n = n.nextSibling) if (n === t) return-1; return e? 1: -1} function de (t) {return function (e) {return "input" === e.nodeName.toLowerCase () && e.type === t}} chức năng he (n) {return function (e) {var t = e.nodeName.toLowerCase (); return ("input" === t || "nút" === t) && e.type === n}} function ge (t) {return function (e) {return "form" trong e? e.parentNode &&! 1 === e.disables? "nhãn" trong e? "nhãn" trong e. ParentNode? e.parentNode.disables === t: e.disables === t: e.isDisables === t || e.isDisables! ==! t && ae (e) === t: e.disables == = t: "nhãn" trong e && e.disables === t}} chức năng ve (a) {return le (function (o) {return o = + o, le (function (e, t) {var n, r = a ([], e.length, o), i = r.length; while (i -) e [n = r [i]] && (e [n] =! (t [n] = e [n )))})})} Hàm ye (e) {return e && "không xác định"! = Typeof e.getElementsByTagName && e} for (e in d = se.support = {}, i = se.isXML = function (e) { var t = e.namespaceURI, n = (e.ownerDocument || e) .documentEuity; return! Y.test (t || n && n.nodeName || "HTML")}, T = se.setDocument = function (e) {var t, n, r = e? e.ownerDocument || e: m; return r! == C && 9 === r.nodeType && r.documentEuity && (a = (C = r) .documentEuity, E =! i (C), m! == C && (n = C.defaultView) && n.top! == n && (n.addEventListener? n.addEventListener ("unload ", oe ,! 1): n.attachEvent && n.attachEvent (" onunload ", oe)), d.attribut = ce (function (e) {return e.groupName =" i ",! e.getAttribution (" className " )}), d.getElementsByTagName = ce (function (e) {return e.appendChild (C.createVer ("")) ,! e.getElementsByTagName ("*"). length}), d.getElementsByClass = (C.getElementsByClassName), d.getById = ce (function (e) {return a.appendChild (e) .id = k ,! C.getElementsByName ||! C.getElementsByName (k) .length}), dget ? (b.filter.ID = function (e) {var t = e.replace (te, ne); hàm trả về (e) {return e.getAttribution ("id") === t}}, b.find .ID = function (e, t) {if ("không xác định"! = Typeof t.getEuityById &&E) {var n = t.getEuityById (e); return n? [N]: []}}) :( b.filter.ID = function (e) {var n = e.replace (te, ne); Hàm trả về (e) {var t = "không xác định"! = typeof e.getAttributionNode && e.getAttributionNode ("id"); return t && t.value === n}}, b.find.ID = function (e, t) { if ("không xác định"! = typeof t.getEuityById && E) {var n, r, i, o = t.getEuityById (e); if (o) {if ((n = o.getAttributionNode ("id")) && n. value === e) return [o]; i = t.getElementsByName (e), r = 0; while (o = i [r ++]) if ((n = o.getAttributionNode ("id")) && n.value === e) return [o]} return []}}), b.find.TAG = d.getElementsByTagName? function (e, t) {return "không xác định"! = typeof t.getElementsByTagName? t.getElementsByTagName ): d.qsa? t.querySelector ALL (e): void 0}: function (e, t) {var n, r = [], i = 0, o = t.getElementsByTagName (e); if ("*" === e) {while (n = o [i ++]) 1 === n.nodeType &&r.push (n); return r} return o}, b.find.CLASS = d.getElementsByClassName && function (e, t) {if ("không xác định"! = typeof t.getElementsByClassName && E) return t.getElements s = [], v = [], (d.qsa = K.test (C.querySelector ALL)) && (ce (hàm (e) {a.appendChild (e) .innerHTML = "<a id = '" + k + "'> </a> <select id ='" + k + "- \ r \\ 'msallowcapture =' '> <tùy chọn được chọn =' '> </ tùy chọn> </ select>", e.querySelector ALL (" [msallowcapture ^ = ''] "). length && v.push (" [* ^ $] = "+ M +" * (?: '' | \ "\") "), e.querySelector ALL (" [đã chọn] ") .length || v.push ("\\ [" + M + "* (?: value |" + R + ")"), e.querySelector ALL ("[id ~ =" + k + "-]"). length | | v.push ("~ ="), e.querySelector ALL (": đã kiểm tra"). length || v.push (": đã kiểm tra"), e.querySelector ALL ("a #" + k + "+ *"). length || v.push (". #. + [+ ~] ")}), ce (chức năng (e) {e.innerHTML =" <a href='' tật ='disables'> </a> <select Bị vô hiệu hóa = 'bị vô hiệu hóa'> <tùy chọn /> </ select > "; var t = C.createEuity (" input "); t.setAttribution (" type "," hidden "), e.appendChild (t) .setAttribution (" name "," D "), e.querySelector ALL ( "[name = d]"). length && v.push ("name" + M + "* [* ^ $ |! ~]? ="), 2! == e.querySelector ALL (": enable"). length && v.push (": enable", ": bị vô hiệu hóa"), a.appendChild (e) .disables =! 0,2! == e.querySelector ALL (": bị vô hiệu hóa") "),e.querySelector ALL ("*,: x"), v.push (",. *:")})), (d.matchesSelector = K.test (c = a.matches || a.webkitMatchesSelector || a. mozMatchesSelector || a.oMatchesSelector || a.msMatchesSelector)) && ce (function (e) {d.disconnectedMatch = c.call (e, "*"), c.call (e, "[s! = '] x "), s.push ("! = ", $)}), v = v.length && RegExp mới (v.join (" | ")), s = s.length && RegExp mới (s.join (" | ") ), t = K.test (a.compareDocumentP vị trí), y = t | | K.test (a.contains)? function (e, t) {var n = 9 === e.nodeType? e.documentEuity: e , r = t && t.parentNode; return e === r ||! (! r || 1! == r.nodeType ||! (n.contains? n.contains (r): e.compareDocumentPocation && 16 & e.compareDocumentPocation )))}: function (e, t) {if (t) while (t = t.parentNode) if (t === e) return! 0; return! 1}, D = t? Hàm (e, t ) {if (e === t) return l =! 0,0; var n =! e.compareDocumentPocation-! t.so sánhDocumentPocation; return n || (1 & (n = (e.ownerDocument || e) === (t.ownerDocument | ) === n? e === C || e.ownerDocument === m && y (m, e)? - 1: t === C | | t.ownerDocument === m && y (m, t)? 1 : u? P (u, e) -P (u, t): 0: 4 & n? -1: 1)}: hàm (e, t) {if (e === t) trả về l =! 0,0 ; var n, r = 0, i = e.parentNode, o = t.parentNode, a = [e], s = [t]; if (! i ||! o) trả lại e === C? -1 : t === C? 1: i? -1: o? 1: u? P (u, e) -P (u, t): 0; if (i === o) trả lại pe (e, t ); n = e; while (n = n.parentNode) a.unshift (n); n = t; while (n = n.parentNode) s.unshift (n); while (a [r] === s [r]) r ++; return r? pe (a [r], s [r]): a [r] === m? -1: s [r] === m? 1: 0}), C }, se.matches = function (e, t) {return se (e, null, null, t)}, se.matchesSelector = function (e, t) {if ((e.ownerDocument || e)! == C && T (e), d.matchesSelector && E &&! A [t + ""] && (! S ||! S.test (t)) && (! V ||! V.test (t))) thử {var n = c.call (e, t); if (n || d.disconnectedMatch || e.document && 11! == e.document.nodeType) return n} Catch (e) { A (t ,! 0)} return 0 <se (t, C, null, [e]). Length}, se.contains = function (e, t) {return (e.ownerDocument || e)! == C && T (e), y (e, t)}, se.attr = function (e, t) {(e.ownerDocument || e)! == C && T (e); var n = b.attrHandle [t.toLowerCase ()], r = n && j.call (b.attrHandle, t.toLowerCase ())? n (e, t ,! E): void 0; return void 0! == r? r: d.attribution ||! E? E.getAttribution (t) :( r = e.getAttributionNode (t)) && r.specified? R.value: null}, se.escape = function (e) {return (e + ""). Thay thế (re, tức là)}, se.error = function (e) {throw new Error ("Lỗi cú pháp, biểu thức không được nhận dạng:" + e)}, se.uniqueSort = function (e) {var t, n = [], r = 0 , i = 0; if (l =! d.detectD repeatates, u =! d.sortStable && e.slice (0), e.sort (D), l) {while (t = e [i ++]) t === e [i] && (r = n.push (i)); while (r -) e.splice (n [r], 1)} return u = null, e}, o = se.getText = function (e) {var t, n = "", r = 0, i = e.nodeType; if (i ) {if (1 === i || 9 === i || 11 === i) {if ("chuỗi" == typeof e.textContent) return e.textContent; for (e = e.firstChild; e; e = e.nextSibling) n + = o (e)} other if (3 === i || 4 === i) return e.nodeValue} khác while (t = e [r ++]) n + = o ( t); return n}, (b = se.selector = {cacheLpm: 50, createdPseudo: le, match: G, attrHandle: {}, find: {}, tương đối: {">": {dir: "ParentNode" , đầu tiên :! 0}, "": {dir: "ParentNode"}, "+": {dir: "trướcSibling", đầu tiên :! 0}, "~": {dir: "trướcSibling"}}, preFilter: {ATTR: function (e) {return e [1] = e [1] .replace (te, ne), e [3] = (e [3] | | e [4] || e [5] || "") .replace (te, ne), "~ =" === e [2] && (e [3] = "" + e [3] + ""), e.slice (0,4)} , TRẺ: hàm (e) {return e [1] = e [1] .toLowerCase (), "nth "=== e [1] .slice (0,3)? (e [3] | | se.error (e [0]), e [4] = + (e [4]? e [5] + (e [6] || 1): 2 * ("chẵn" === e [3] || "lẻ" === e [3])), e [5] = + (e [7] + e [8] || "lẻ" === e [3])): e [3] && se.error (e [0]), e}, PSEUDO: function (e) {var t, n =! e [6] && e [2]; trả lại G.CHILD.test (e [0])? null: (e [3]? e [2] = e [4] || e [5] || "": n && X.test (n) && (t = h (n ,! 0)) && (t = n.indexOf (")", n.length-t) -n.length) && (e [0] = e [ 0] .slice (0, t), e [2] = n.slice (0, t)), e.slice (0,3))}}, bộ lọc: {TAG: function (e) {var t = e.replace (te, ne) .toLowerCase (); return "*" === e? function () {return! 0}: function (e) {return e.nodeName && e.nodeName.toLowerCase () === t }}, LỚP: function (e) {var t = p [e + ""]; return t || (t = new RegExp ("(^ |" + M + ")" + e + "(" + M + "| $ ) ")) && p (e, hàm (e) {return t.test (" chuỗi "== typeof e.groupName && e.groupName || "không xác định"! = typeof e.getAttribution && e.getAttribution ("class") || "")})}, ATTR: function (n, r, i) {return function (e ) {var t = se.attr (e, n); return null == t? "! =" === r :! r || (t + = "", "=" === r? t == = i: "! =" === r? t! == i: "^ =" === r? i && 0 === t.indexOf (i): "* =" === r? i && - 1 <t.indexOf (i): "$ =" === r? i && t.slice (-i.length) === i: "~ =" === r? -1 <"" + t.replace (F, "") + "") .indexOf (i): "| =" === r && (t === i || t.slice (0, i.length + 1) === i + "- "))}}, TRẺ: hàm (h, e, t, g, v) {var y =" nth "! == h.slice (0,3), m =" last "! == h.slice (-4), x = "of-type" === e; return 1 === g && 0 === v? Hàm (e) {return !! e.parentNode}: function (e, t, n) { var r, i, o, a, s, u, l = y!== m? "nextSibling": "trướcSibling", c = e.parentNode, f = x && e.nodeName.toLowerCase (), p =! n &&! x, d =! 1; if (c) {if (y) { while (l) {a = e; while (a = a [l]) if (x? a.nodeName.toLowerCase () === f: 1 === a.nodeType) return! 1; u = l = "chỉ" === h &&! u && "nextSibling"} return! 0} if (u = [m? c.firstChild: c.lastChild], m && p) {d = (s = (r = (i = (o = (a = c) [k] || (a [k] = {})) [a.uniqueID] || (o [a.uniqueID] = {})) [h] || []) [0] === S && r [1]) && r [2], a = s && c.childNodes [s]; while (a = ++ s && a && a [l] || (d = s = 0) || u.pop ()) nếu (1 === a.nodeType && ++ d && a === e) {i [h] = [S, s, d]; break}} khác if (p && (d = s = (r = (i = (o = = (a = e) [k] || (a [k] = {})) [a.uniqueID] || (o [a.uniqueID] = {})) [h] || []) [0 ] === S && r [1]),! 1 === d) while (a = ++ s && a && a [l] || (d = s = 0) || u.pop ()) if ((x? A .nodeName.toLowerCase () === f: 1 === a.nodeType) &&++ d && (p && ((i = (o = a [k] || (a [k] = {})) [a.uniqueID] || (o [a.uniqueID] = {})) [h] = [S, d]), a === e)) break; return (d- = v) === g || d% g == 0 && 0 <= d / g}}}, PSEUDO: function (e , o) {var t, a = b.pseudos [e] || b.setFilters [e.toLowerCase ()] || se.error ("giả không được hỗ trợ:" + e); trả về [k]? a ( o): 1 <a.length? (t = [e, e, "", o], b.setFilters.hasOwnProperty (e.toLowerCase ())? le (hàm (e, t) {var n, r = a (e, o), i = r.length; while (i -) e [n = P (e, r [i])] =! (t [n] = r [i])}): hàm (e) {return a (e, 0, t)}): a}}, pseudos: {not: le (function (e) {var r = [], i = [], s = f (e.replace (B, "$ 1")); return s [k]? Le (hàm (e, t, n, r) {var i, o = s (e, null, r, []), a = e.length ; while (a -) (i = o [a]) && (e [a] =! (t [a] = i))}): hàm (e, t, n) {return r [0] = e, s (r, null, n, i), r [0] = null ,! i.pop ()}}), có: le (function (t) {return function (e) {return 0 <se ( t, e) .length}}), chứa: le (hàm (t) {return t = t.replace (te,ne), hàm (e) {return-1 <(e.textContent || o (e)). indexOf (t)}}), lang: le (function (n) {return V.test (n || " ") || se.error (" lang không được hỗ trợ: "+ n), n = n.replace (te, ne) .toLowerCase (), function (e) {var t; do {if (t = E? E. lang: e.getAttribution ("xml: lang") || e.getAttribution ("lang")) return (t = t.toLowerCase ()) === n || 0 === t.indexOf (n + "- ")} while ((e = e.parentNode) && 1 === e.nodeType); return! 1}}), đích: function (e) {var t = n.location && n.location.hash; return t && t.slice (1) === e.id}, root: function (e) {return e === a}, tập trung: function (e) {return e === C.activeEuity && (! C.hasF Focus || C. hasF Focus ()) && !! (e.type || e.href | = e.nodeName.toLowerCase (); trả về "input" === t && !! e.checked || "tùy chọn" === t && !! e.selected}, đã chọn:function (e) {return e.parentNode && e.parentNode.selected Index ,! 0 === e.selected}, blank: function (e) {for (e = e.firstChild; e; e = e.nextSibling) if (e .nodeType <6) return! 1; return! 0}, Parent: function (e) {return! b.pseudos.empty (e)}, tiêu đề: function (e) {return J.test (e.nodeName)} , input: function (e) {return Q.test (e.nodeName)}, button: function (e) {var t = e.nodeName.toLowerCase (); return "input" === t && "button" == = e.type || "nút" === t}, text: function (e) {var t; return "input" === e.nodeName.toLowerCase () && "text" === e.type && ( null == (t = e.getAttribution ("type")) || "text" === t.toLowerCase ())}, đầu tiên: ve (function () {return [0]}), last: ve ( hàm (e, t) {return [t-1]}), eq: ve (hàm (e, t, n) {return [n <0? n + t: n]}), thậm chí: ve (hàm ( e, t) {for (var n = 0; n <t; n + = 2) e.push (n); return e}), lẻ: ve (hàm (e,t) {for (var n = 1; n <t; n + = 2) e.push (n); return e}), lt: ve (hàm (e, t, n) {for (var r = n < 0? N + t: t <n? T: n; 0 <= - r;) e.push (r); return e}), gt: ve (hàm (e, t, n) {for (var r = n <0? n + t: n; ++ r <t;) e.push (r); return e})}}). pseudos.nth = b.pseudos.eq, {radio :! 0, hộp kiểm :! 0, tệp :! 0, mật khẩu :! 0, hình ảnh :! 0}) b.pseudos [e] = de (e); for (e in {submit :! 0, đặt lại :! 0}) b .pseudos [e] = he (e); function me () {} chức năng xe (e) {for (var t = 0, n = e.length, r = ""; t <n; t ++) r + = e [t] .value; return r} hàm be (s, e, t) {var u = e.dir, l = e.next, c = l | | u, f = t && "ParentNode" === c, p = r ++; return e.first? function (e, t, n) {while (e = e [u]) if (1 === e.nodeType || f) return s (e, t, n); return! 1}: function (e, t, n) {var r, i, o, a = [S, p]; if (n) {while (e = e [u]) if ((1 === e.nodeType | | f) && s (e, t, n)) trả về! 0} khác trong khi (e = e [u]) if (1 === e.nodeType || f) if (i = (o = e [k] || (e [k] = {})) [e.uniqueID] || (o [e.uniqueID] = {}), l && l === e.nodeName.toLowerCase ()) e = e [u] || e; other {if ((r = i [c]) && r [0] === S && r [1] === p) return a [2] = r [2]; if ((i [c] = a) [2] = s (e, t, n)) return! 0} return! 1}} chức năng chúng tôi (i) {return 1 <i.length? hàm (e, t, n) {var r = i.length; while (r -) if (! i [r] (e, t, n)) return! 1; return! 0}: i [0] } hàm Te (e, t, n, r, i) {for (var o, a = [], s = 0, u = e.length, l = null! = t; s <u; s ++) (o = e [s]) && (n &&! n (o, r, i) || (a.push (o), l && t.push (s))); trả về hàm}} Ce (d, h, g, v , y, e) {return v &&! v [k] && (v = Ce (v)), y &&! y [k] && (y = Ce (y, e)), le (hàm (e, t, n , r) {var i, o, a, s = [], u = [], l = t.length, c = e | | hàm (e, t, n) {for (var r = 0, i = t.length; r <i; r ++) se (e, t [r], n); return n} (h | | "*", n.nodeType? [n]: n, []), f =! d ||! e && h? c: Te (c, s, d, n, r), p = g? y | | (e? d: l | | v)? []: t: f; if (g && g ( f, p, n, r), v) {i = Te (p, u), v (i, [], n, r), o = i.length; while (o -) (a = i [ o]) && (p [u [o]] =!(f [u [o]] = a))} if (e) {if (y | | d) {if (y) {i = [], o = p.length; while (o -) (a = p [o]) && i.push (f [o] = a); y (null, p = [], i, r)} o = p.length; while (o -) (a = p [o ]) && - 1 <(i = y? P (e, a): s [o]) && (e [i] =! (T [i] = a))}} khác p = Te (p == = t? p.splice (l, p.length): p), y? y (null, t, p, r): H.apply (t, p)})} chức năng Ee (e) {for (var i, t, n, r = e.length, o = b.relative [e [0] .type], a = o || b.relative [""], s = o? 1: 0, u = be (hàm (e) {return e === i}, a ,! 0), l = be (hàm (e) {return-1 <P (i, e)}, a ,! 0), c = [ hàm (e, t, n) {var r =! o && (n || t! == w) || ((i = t) .nodeType? u (e, t, n): l (e, t, n)); return i = null, r}]; s <r; s ++) if (t = b.relative [e [s] .type]) c = [be (we (c), t)]; other {if ((t = b.filter [e [s] .type] .apply (null, e [s] .matches)) [k]) {for (n = ++ s; n <r; n ++) nếu (b.relative [e [n] .type]) break; return Ce (1 <s && we (c), 1 <s && xe (e.slice (0, s-1) .concat ({value: "" === e [s-2] .type? "*": ""})). thay thế (B, "$ 1"), t, s <n && Ee (e.slice (s, n)), n <r && Ee (e = e.slice (n)), n <r && xe (e)) } c.push (t)} return we (c)} return me.prototype = b.filters = b.pseudos, b.setFilters = new me, h = se.tokenize = function (e, t) {var n, r, i, o, a, s, u, l = x [e + ""]; if (l) trả về t? 0: l.slice (0); a = e, s = [], u = b. preFilter; while (a) {for (o in n &&! (r = _. exec (a)) || (r && (a = a.slice (r [0] .length) || a), s.push ( i = [])), n =! 1, (r = z.exec (a)) && (n = r.shift (), i.push ({value: n, type: r [0] .replace ( B, "")}), a = a.slice (n.length)), b.filter)! (R = G [o] .exec (a)) || u [o] &&! (R = u [o] (r)) || (n = r.shift (), i.push ({value: n, type: o, trùng khớp: r}), a = a.slice (n.length)); if (! n) break} return t? a.length: a? se.error (e): x (e, s) .slice (0)}, f = se.compile = function (e, t) {var n , v, y, m, x, r, i = [], o = [], a = N [e + ""]; if (! a) {t | | (t = h (e)), n = t.length; while (n -) (a = Ee (t [n])) [k]? i.đẩy (a): o.push (a); (a = N (e, (v = o, m = 0 <(y = i) .length, x = 0 <v.length, r = function (e, t, n, r, i) {var o, a, s, u = 0, l = "0", c = e && [], f = [], p = w, d = e || x && b.find. TAG ("*", i), h = S + = null == p? 1: Math.random () || .1, g = d.length; for (i && (w = t === C || t || i); l! == g && null! = (o = d [l]); l ++) {if (x && o) {a = 0, t || o.ownerDocument === C || (T (o) , n =! E); while (s = v [a ++]) if (s (o, t || C, n)) {r.push (o); break} i && (S = h)} m && (( o =! s && o) && u -, e && c.push (o))} if (u + = l, m && l! == u) {a = 0; while (s = y [a ++]) s (c, f, t , n); if (e) {if (0 <u) while (l -) c [l] || f [l] | | (f [l] = q.call (r)); f = Te (f)} H.apply (r, f), i &&! e && 0 <f.length && 1 <u + y.length && se.uniqueSort (r)} trả lại i && (S = h, w = p), c}, m? le (r): r))). selector = e} return a}, g = se.select = function (e, t, n, r) {var i, o, a, s, u, l = "function" == typeof e && e, c =!r && h (e = l.selector || e); if (n = n || [], 1 === c.length) {if (2 <(o = c [0] = c [0] .slice ( 0)). Chiều dài && "ID" === (a = o [0]). Type && 9 === t.nodeType && E && b.relative [o [1] .type]) {if (! (T = (b.find. ID (a.matches [0] .replace (te, ne), t) || []) [0])) return n; l && (t = t.parentNode), e = e.slice (o.shift ( ) .value.length)} i = G.needContext.test (e)? 0: o.length; while (i -) {if (a = o [i], b.relative [s = a.type] ) break; if ((u = b.find [s]) && (r = u (a.matches [0] .replace (te, ne), ee.test (o [0] .type) && ye (t. ParentNode) | | t))) {if (o.splice (i, 1) ,! (e = r.length && xe (o))) return H.apply (n, r), n; break}}} return ( l || f (e, c)) (r, t ,! E, n ,! t || ee.test (e) && ye (t.parentNode) || t), n}, d.sortStable = k. split (""). sort (D) .join ("") === k, d.detectD repeatates = !! l, T (), d.sortDetached = ce (function (e) {return 1 & e.compareDocumentP vị trí (C) .createEuity ("fieldset "))}), ce (function (e) {return e.innerHTML =" <a href='#'> </a> "," # "=== e.firstChild.getAttribution (" href ") }) || fe ("loại | href | chiều cao | chiều rộng", hàm (e, t, n) {if (! n) return e.getAttribution (t, "type" === t.toLowerCase ()? 1 : 2)}), d.attribut && ce (function (e) {return e.innerHTML = "<input />", e.firstChild.setAttribution ("value", ""), "" === e.firstChild. getAttribution ("value")}) || fe ("value", function (e, t, n) {if (! n && "input" === e.nodeName.toLowerCase ()) return e.defaultValue}), ce (function (e) {return null == e.getAttribution ("bị vô hiệu hóa")}) || fe (R, function (e, t, n) {var r; if (! n) return! 0 === e [t]? t.toLowerCase () :( r = e.getAttributionNode (t)) && r.specified? r.value: null}), se} (C); k.find = h, k.expr = h .selector, k.expr [":"] = k.expr.pseudos, k.uniqueSort = k.unique = h.uniqueSort, k.text = h.getText, k.isXMLDoc = h.isXML, k. .escape; var T = function (e, t, n) {var r = [], i = void 0! == n; while ((e = e [t]) && 9! == e.nodeType) if ( 1 === e.nodeType) {if (i && k (e) .is (n)) break; r.push (e)} return r}, S = function (e, t) {for (var n = [] ; e; e = e.nextSibling) 1 === e.nodeType && e! == t && n.push (e); return n}, N = k.expr.match.needContext; function A (e, t) {return e .nodeName && e.nodeName.toLowerCase () === t.toLowerCase ()} var D = / ^ <([az] [^ \ / \ 0>: \ x20 \ t \ r \ n \ f] *) [\ x20 \ t \ r \ n \ f] * \ /?> (?: <\ / \ 1> |) $ / i; hàm j (e, n, r) {return m (n)? k.grep ( e, hàm (e, t) {return !! n.call (e, t, e)! == r}): n.nodeType? k.grep (e, function (e) {return e === n ! == r}): "chuỗi"! = typeof n? k.grep (e, function (e) {return-1 <i.call (n, e)! == r}): k.filter (n , e, r)} k.filter = chức năng (e, t,n) {var r = t [0]; return n && (e = ": not (" + e + ")"), 1 === t.length && 1 === r.nodeType? k.find.matchesSelector (r, e)? [r]: []: k.find.matches (e, k.grep (t, function (e) {return 1 === e.nodeType}))}, k.fn.extend ({find : function (e) {var t, n, r = this.length, i = this; if ("string"! = typeof e) return this.pushStack (k (e) .filter (function () {for (t = 0; t <r; t ++) if (k.contains (i [t], this)) return! 0})); for (n = this.pushStack ([]), t = 0; t <r; t ++) k.find (e, i [t], n); return 1 <r? k.uniqueSort (n): n}, filter: function (e) {return this.pushStack (j (this, e || [],! 1))}, không phải: function (e) {return this.pushStack (j (this, e || [],! 0))}, là: function (e) {return !! j (this , "chuỗi" == typeof e && N.test (e)? k (e): e || [],! 1) .length}}); var q, L = / ^ (?: \ s * (<[ \ w \ W] +>) [^>] * | # ([\ w -] +)) $ /; (k.fn.init = hàm (e, t, n) {var r, i; if ( ! e) trả lại cái này; if (n = n || q, "chuỗi" == typeof e) {if (!(r = "<" === e [0] && ">" === e [e.length-1] && 3 <= e.length? [null, e, null]: L.exec (e)) | |! r [1] && t) return! t || t.jquery? (t || n) .find (e): this.constructor (t) .find (e); if (r [1]) { if (t = t instanceof k? t [0]: t, k.merge (this, k.parseHTML (r [1], t && t.nodeType? t.ownerDocument || t: E ,! 0)), D. kiểm tra (r [1]) && k.isPlainObject (t)) cho (r in t) m (this [r])? this [r] (t [r]): this.attr (r, t [r]) ; return this} return (i = E.getEuityById (r [2])) && (this [0] = i, this.length = 1), this} return e.nodeType? (this [0] = e, this .length = 1, this): m (e)? void 0! == n. yet? n. yet (e): e (k): k.makeArray (e, this)}) .otype = k.fn , q = k (E); var H = / ^ (?: cha mẹ | trước (?: Until | All)) /, O = {con :! 0, nội dung :! 0, tiếp theo :! 0, trước :! 0}; hàm P (e, t) {while ((e = e [t]) && 1! == e.nodeType); return e} k.fn.extend ({has: function (e) {var t = k (e, cái này), n = t.length; trả lại cái này.bộ lọc (hàm () {for (var e = 0; e <n; e ++) if (k.contains (this, t [e])) return! 0})}, gần nhất: function (e, t) {var n, r = 0, i = this.length, o = [], a = "chuỗi"! = typeof e && k (e); if (! N.test (e)) cho (; r <i; r ++) cho (n = this [r]; n && n! == t; n = n.parentNode) if (n.nodeType <11 && (a? -1 <a.index (n): 1 === n.nodeType && k.find. MatchSelector (n, e))) {o.push (n); break} return this.pushStack (1 <o.length? k.uniqueSort (o): o)}, index: function (e) {return e? "chuỗi" == typeof e? i.call (k (e), this [0]): i.call (this, e.jquery? e [0]: e): this [0] && this [0]. ParentNode? this.first (). trước đó (). length: -1}, add: function (e, t) {return this.pushStack (k.uniqueSort (k.merge (this.get (), k (e, t))))}, addBack: function (e) {return this.add (null == e? this.prevObject: this.prevObject.filter (e))}}), k.each ({Parent: function ( e) {var t = e.parentNode; return t && 11! == t.nodeType? t:null}, cha mẹ: function (e) {return T (e, "ParentNode")}, ParentUntil: function (e, t, n) {return T (e, "ParentNode", n)}, next: function (e ) {return P (e, "nextSibling")}, trước: function (e) {return P (e, "trướcSibling")}, nextAll: function (e) {return T (e, "nextSibling")}, trước : function (e) {return T (e, "trướcSibling")}, nextUntil: function (e, t, n) {return T (e, "nextSibling", n)}, trướcUntil: function (e, t, n ) {return T (e, "trướcSibling", n)}, anh chị em: function (e) {return S ((e.parentNode || {}). firstChild, e)}, children: function (e) {return S (e.firstChild)}, nội dung: function (e) {return "không xác định"! = typeof e.contentDocument? e.contentDocument: (A (e, "template") && (e = e.content || e), k.merge ([], e.childNodes))}}, hàm (r, i) {k.fn [r] = function (e, t) {var n = k.map (this, i, e); trở lại "Cho đến khi"!== r.slice (-5) && (t = e), t && "chuỗi" == typeof t && (n = k.filter (t, n)), 1 <this.length && (O [r] || k .uniqueSort (n), H.test (r) && n.reverse ()), this.pushStack (n)}}); var R = / [^ \ x20 \ t \ r \ n \ f] + / g; hàm M (e) {return e} chức năng I (e) {throw e} chức năng W (e, t, n, r) {var i; thử {e && m (i = e.promise)? i.call (e) .done (t) .fail (n): e && m (i = e.then)? i.call (e, t, n): t.apply (void 0, [e] .slice (r))} Catch ( e) {n.apply (void 0, [e])}} k.Callbacks = function (r) {var e, n; r = "chuỗi" == typeof r? (e = r, n = {}, k.each (e.match (R) || [], hàm (e, t) {n [t] =! 0}), n): k.extend ({}, r); var i, t, o, a, s = [], u = [], l = -1, c = function () {for (a = a | | r.once, o = i =! 0; u.length; l = - 1) {t = u.shift (); while (++ l <s.length)! 1 === s [l] .apply (t [0], t [1]) && r.stopOnFalse && (l = s .length, t =! 1)} r.memory || (t =! 1), i =! 1, a && (s = t? []: "")}, f = {add: function () {return S&& (t &&! i && (l = s.length-1, u.push (t)), hàm n (e) {k.each (e, function (e, t) {m (t)? r.unique && f. has (t) || s.push (t): t && t.length && "chuỗi"! == w (t) && n (t)})} (đối số), t &&! i && c ()), this}, remove: function () {return k.each (đối số, hàm (e, t) {var n; while (-1 <(n = k.inArray (t, s, n))) s.splice (n, 1), n <= l && l -}), this}, has: function (e) {return e? -1 <k.inArray (e, s): 0 <s.length}, blank: function () {return s && (s = []), this}, vô hiệu hóa: function () {return a = u = [], s = t = "", this}, bị vô hiệu hóa: function () {return! s}, lock: function () {return a = u = [], t || i || (s = t = ""), cái này}, bị khóa: function () {return !! a}, fireWith: function (e, t) {return a || (t = [e, (t = t || []). lát? t.slice (): t], u.push (t), i | | c ()), này}, fire: function () {return f.fireWith (this, argument), this}, fire: function () {return !! o}};return f}, k.extend ({Trì hoãn: function (e) {var o = [["thông báo", "tiến trình", k.Callbacks ("memory"), k.Callbacks ("memory"), 2], ["giải quyết", "thực hiện", k.Callbacks ("bộ nhớ một lần"), k.Callbacks ("bộ nhớ một lần"), 0, "đã giải quyết"], ["từ chối", "fail", k.Callbacks (" một lần bộ nhớ "), k.Callbacks (" bộ nhớ một lần "), 1," bị từ chối "]], i =" cấp phát ", a = {state: function () {return i}, always: function () {return s .done (argument) .fail (argument), this}, "Catch": function (e) {return a.then (null, e)}, pipe: function () {var i = argument; return k.Deferred ( hàm (r) {k.each (o, function (e, t) {var n = m (i [t [4]]) && i [t [4]]; s [t [1]] (function () {var e = n && n.apply (this, argument); e && m (e.promise)? e.promise (). tiến trình (r.notify) .done (r.resolve) .fail (r.từ chối): r [t [0] + "With"] (this, n? [e]: argument)})}), i = null}). hứa ()}, sau đó: function (t, n, r ) {var u = 0; function l (i, o, a, s) {return function () {var n = this, r = argument, e = function () {var e, t; if (! (i < u)) {if ((e = a.apply (n, r)) === o.promise ()) ném TypeError mới ("Có thể tự giải quyết"); t = e && ("object" == typeof e || "hàm" == typeof e) && e.then, m (t)? s? t.call (e, l (u, o, M, s), l (u, o, I, s)): (u ++, t.call (e, l (u, o, M, s), l (u, o, I, s), l (u, o, M, o.notifyWith))) :( a! = = M && (n = void 0, r = [e]), (s || o.resolveWith) (n, r))}}, t = s? E: function () {thử {e ()} Catch ( e) {k.Deferred.exceptionHook && k.Deferred.exceptionHook (e, t.stackTrace), u <= i + 1 && (a! , r))}}; i? t () :( k.Deferred.getStackHook && (t.stackTrace = k.Deferred.getStackHook ()), C.setTimeout (t))}} return k.Trì hoãn (hàm (e) {o [0] [3] .add (l (0, e, m (r)? R: M, e.notifyWith)), o [1] [3] .add (l ( 0, e, m (t)? T: M)), o [2] [3] .add (l (0, e, m (n)? N: I))}). Prom ()}, lời hứa : function (e) {return null! = e? k.extend (e, a): a}}, s = {}; return k.each (o, function (e, t) {var n = t [2 ], r = t [5]; a [t [1]] = n.add, r && n.add (function () {i = r}, o [3-e] [2] .disable, o [3- e] [3] .disable, o [0] [2] .lock, o [0] [3] .lock), n.add (t [3] .fire), s [t [0]] = chức năng () {return s [t [0] + "With"] (this === s? void 0: this, argument), this}, s [t [0] + "With"] = n.fireWith}) , a.promise (s), e && e.call (s, s), s}, khi: function (e) {var n = argument.length, t = n, r = Array (t), i = s.call (đối số), o = k.Deferred (), a = function (t) {return function (e) {r [t] = this, i [t] = 1 <argument.length? s.call (argument): e, - n || o.resolveWith (r, i)}}; if (n <= 1 && (W (e, o.done (a (t)). giải quyết, o.reject ,! n), " đang chờ xử lý "=== o.state () || m (i [t] && i [t].sau đó))) return o.then (); while (t -) W (i [t], a (t), o.reject); return o.promise ()}}); var $ = / ^ ( Eval | Internal | Range | Reference | Cú pháp | Loại | URI) Lỗi $ /; k.Deferred.exceptionHook = function (e, t) {C.console && C.console.warn && e && $. Test (e.name) && C.console. cảnh báo ("jQuery.Deferred ngoại lệ:" + e.message, e.stack, t)}, k. yetException = function (e) {C.setTimeout (function () {throw e})}; var F = k. Trì hoãn (); hàm B () {E.removeEventListener ("DOMContentLoaded", B), C.removeEventListener ("load", B), k. Yet ()} k.fn. Yet = function (e) {return F .then (e) ["Catch"] (function (e) {k. yetException (e)}), this}, k.extend ({isReady :! 1, readyWait: 1, ready: function (e) {( ! 0 === e? - k. YetWait: k.isReady) || (k.isReady =! 0)! == e && 0 <- k. YetWait || F.resolveWith (E, [k])} }), k. yet.then = F.then, "hoàn thành" === E. yetState || "đang tải "! == E. yetState &&! E.documentEuity.doScroll? C.setTimeout (k. đã) :( E.addEventListener (" DOMContentLoaded ", B), C.addEventListener (" load ", B)); var _ = hàm (e, t, n, r, i, o, a) {var s = 0, u = e.length, l = null == n; if ("object" === w (n)) cho (s in i =! 0, n) _ (e, t, s, n [s],! 0, o, a); khác if (void 0! == r && (i =! 0, m (r) || (a =! 0), l && (a? (t.call (e, r), t = null) :( l = t, t = function (e, t, n) {return l.call (k (e), n)})), t)) cho (; s <u; s ++) t (e [s], n, a? r: r.call (e [s], s, t (e [ s], n))); return i? e: l? t.call (e): u? t (e [0], n): o}, z = / ^ - ms - /, U = / - ([az]) / g; function X (e, t) {return t.toUpperCase ()} chức năng V (e) {return e.replace (z, "ms -"). thay thế (U, X)} var G = function (e) {return 1 === e.nodeType || 9 === e.nodeType ||! + E.nodeType}; function Y () {this.Exando = k.Exando + Y.uid ++} Y.uid = 1, Y.prototype = {cache: function (e) {var t = e [this.Exando]; return t || (t = {}, G (e) && (e.nodeType? e [this.Exando] = t: Object.defineProperty (e, this.Exando, {value: t, configureable :! 0}))), t}, set: function (e, t, n) {var r, i = this.cache (e); if ("chuỗi" == typeof t) i [V (t)] = n; khác cho (r in t) i [V (r)] = t [r]; return i}, get: function (e, t) {return void 0 === t? this.cache (e): e [this.Exando] && e [this.Exando] [V (t) ]}, access: function (e, t, n) {return void 0 === t || t && "chuỗi" == typeof t && void 0 === n? this.get (e, t) :( this.set (e, t, n), void 0! == n? n: t)}, remove: function (e, t) {var n, r = e [this.Exando]; if (void 0! == r ) {if (void 0! == t) {n = (t = Array.isArray (t)? t.map (V) :( t = V (t)) trong r? [t]: t.match ( R) || []). Chiều dài; while (n -) xóa r [t [n]]} (void 0 === t || k.isEmptyObject (r)) && (e.nodeType? E [này .Exando] = void 0: xóa e [this.Exando])}}, hasData: function (e) {var t = e [this.Exando]; return void 0! == t &&! k.isEmptyObject (t)} }; var Q = new Y, J = new Y,K = / ^ (?: \ {[\ W \ W] * \} | \ [[\ w \ W] * \]) $ /, Z = / [AZ] / g; chức năng ee (e, t, n) {var r, i; if (void 0 === n && 1 === e.nodeType) if (r = "data -" + t.replace (Z, "- $ &"). toLowerCase (), " chuỗi "== typeof (n = e.getAttribution (r))) {thử {n =" true "=== (i = n) ||" false "! == i && (" null "=== i? null: i === + i + ""? + i: K.test (i)? JSON.parse (i): i)} Catch (e) {} J.set (e, t, n)} other n = void 0; return n} k.extend ({hasData: function (e) {return J.hasData (e) | | Q.hasData (e)}, data: function (e, t, n) {return J. truy cập (e, t, n)}, removeData: function (e, t) {J.remove (e, t)}, _ data: function (e, t, n) {return Q.access (e, t, n )}, _ removeData: function (e, t) {Q.remove (e, t)}}), k.fn.extend ({data: function (n, e) {var t, r, i, o = this [0], a = o && o.attribut; if (void 0 === n) {if (this.length && (i = J.get (o), 1 === o.nodeType &&! Q.get (o, " hasDataAttrs "))) {t = a.length;while (t -) a [t] && 0 === (r = a [t] .name) .indexOf ("data -") && (r = V (r.slice (5)), ee (o, r, i [r])); Q.set (o, "hasDataAttrs" ,! 0)} return i} return "object" == typeof n? this.each (function () {J.set (this, n )}): _ (this, function (e) {var t; if (o && void 0 === e) return void 0! == (t = J.get (o, n))? t: void 0! = = (t = ee (o, n))? t: void 0; this.each (function () {J.set (this, n, e)})}, null, e, 1 <argument.length, null ,! 0)}, removeData: function (e) {return this.each (function () {J.remove (this, e)})}}), k.extend ({queue: function (e, t, n ) {var r; if (e) return t = (t || "fx") + "queue", r = Q.get (e, t), n && (! r || Array.isArray (n)? r = Q.access (e, t, k.makeArray (n)): r.push (n)), r || []}, dequeue: function (e, t) {t = t || "fx"; var n = k.queue (e, t), r = n.length, i = n.shift (), o = k._queueHooks (e, t); "inproceed" === i && (i = n.shift (), r -), i && ("fx "=== t && n.unshift (" inprowards "), xóa o.stop, i.call (e, function () {k.dequeue (e, t)}, o)) ,! r && o && o.empty.fire ( )}, _ queueHooks: function (e, t) {var n = t + "queueHooks"; return Q.get (e, n) | | Q.access (e, n, {blank: k.Callbacks ("một lần bộ nhớ" ) .add (function () {Q.remove (e, [t + "queue", n])})})}}), k.fn.extend ({queue: function (t, n) {var e = 2; trả về "chuỗi"! = Typeof t && (n = t, t = "fx", e -), argument.length <e? K.queue (this [0], t): void 0 === n ? this: this.each (function () {var e = k.queue (this, t, n); k._queueHooks (this, t), "fx" === t && "inprowards"! == e [0 ] && k.dequeue (this, t)})}, dequeue: function (e) {return this.each (function () {k.dequeue (this, e)})}, clearQueue: function (e) {return this .queue (e || "fx", [])}, lời hứa: function (e, t) {var n, r = 1, i = k.Deferred (), o = this, a = this.độ dài, s = function () {- r || i.resolveWith (o, [o])}; "chuỗi"! = typeof e && (t = e, e = void 0), e = e || "fx "; while (a -) (n = Q.get (o [a], e +" queueHooks ")) && n.empty && (r ++, n.empty.add (s)); return s (), i.promise (t)}}); var te = / [+ -]? (?: \ d * \. |) \ d + (?: [eE] [+ -]? \ d + |) /. source, ne = new RegExp ("^ (?: ([+ -]) = |) (" + te + ") ([az%] *) $", "i"), re = ["Trên cùng", "Phải", "Dưới cùng "," Trái "], tức là = E.documentE bổ sung, oe = function (e) {return k.contains (e.ownerDocument, e)}, ae = {comp :! 0}; tức là.getRootNode && (oe = function ( e) {return k.contains (e.ownerDocument, e) || e.getRootNode (ae) === e.ownerDocument}); var se = function (e, t) {return "none" === (e = t || e) .style.display || "" === e.style.display && oe (e) && "none" === k.css (e, "display")}, ue = function (e, t, n,r) {var i, o, a = {}; for (o in t) a [o] = e.style [o], e.style [o] = t [o]; for (o in i = n .apply (e, r || []), t) e.style [o] = a [o]; return i}; hàm le (e, t, n, r) {var i, o, a = 20 , s = r? function () {return r.cur ()}: function () {return k.css (e, t, "")}, u = s (), l = n && n [3] || ( k.cssNumber [t]? "": "px"), c = e.nodeType && (k.cssNumber [t] || "px"! == l && + u) && ne.exec (k.css (e, t )); if (c && c [3]! == l) {u / = 2, l = l || c [3], c = + u | | 1; while (a -) k.style (e, t, c + l), (1-o) * (1- (o = s () / u | | .5)) <= 0 && (a = 0), c / = o; c * = 2, k .style (e, t, c + l), n = n || []} return n && (c = + c | | + u || 0, i = n [1]? c + (n [1] +1 ) * n [2]: + n [2], r && (r.unit = l, r.start = c, r.end = i)), i} var ce = {}; chức năng fe (e, t) {for (var n, r, i, o, a, s, u, l = [], c = 0, f = e.length; c <f; c ++) (r = e [c]). style && ( n = r.style.display, t? ("none" === n && (l [c] = Q.get (r, "display") | | null, l [c] || (r.style.display = "")), "" === r.style.display && se (r) && (l [c] = (u = a = o = void 0, a = (i = r) .ownerDocument, s = i.nodeName, (u = ce [s]) || (o = a.body.appendChild (a.createEuity (s)), u = k.css (o, "display"), o.parentNode.removeChild (o), "none" === u && (u = "block"), ce [s] = u)))): "none"! == n && (l [c] = "none", Q.set (r, "hiển thị", n))); for (c = 0; c <f; c ++) null! = l [c] && (e [c] .style.display = l [c]); return e } k.fn.extend ({show: function () {return fe (this ,! 0)}, hide: function () {return fe (this)}, toggle: function (e) {return "boolean" == typeof e? e? this.show (): this. leather (): this.each (function () {se (this)? k (this) .show (): k (this). leather ()})} }); var pe = / ^ (?: hộp kiểm | radio) $ / i, de = / <([az] [^ \ / \ 0> \ x20 \ t \ r \ n \ f] *) / i, he = / ^ $ | ^ mô-đun $ | \ / (?: java | ecma) script / i, ge = {tùy chọn: [1, "<chọn nhiều = 'nhiều'> "," </ select> "], thead: [1," <bảng> "," </ bảng> "], col: [2," <bảng> <colgroup> ", "</ colgroup> </ table>"], tr: [2, "<bảng> <tbody>", "</ tbody> </ bảng>"], td: [3, "<bảng> <tbody> <tr> "," </ tr> </ tbody> </ table> "], _ default: [0," "," "]}; function ve (e, t) {var n; return n =" không xác định "! = typeof e.getElementsByTagName? e.getElementsByTagName (t ||" * "):" không xác định "! = typeof e.querySelector ALL? e.querySelector ALL (t ||" * "): [] t || t && A (e, t)? k.merge ([e], n): n} hàm ye (e, t) {for (var n = 0, r = e.length; n <r; n ++) Q.set (e [n], "globalEval" ,! T || Q.get (t [n], "globalEval"))} ge.optgroup = ge.option, ge.tbody = ge.tfoot = ge.colgroup = ge.caption = ge.thead, ge.th = ge.td; var me, xe, be = / <| & #? \ w +; /; hàm ta (e, t, n, r, i) {for (var o, a, s, u, l, c, f = t.createDocumentFragment (), p = [], d = 0, h = e.length; d <h; d ++) if ((o = e [d]) || 0 === o) if ("object" === w (o)) k.merge (p, o.nodeType ? [o]: o); other if (be.test (o)) {a = a || f.appendChild (t.createEuity ("div")), s = (de.exec (o) || [ "", ""]) [1] .toLowerCase (), u = ge [s] || ge._default, a.innerHTML = u [1] + k.htmlPrefilter (o) + u [2], c = u [0]; while (c -) a = a.lastChild; k.merge (p, a.childNodes), (a = f.firstChild) .textContent = ""} khác p.push (t.createTextNode ( o)); f.textContent = "", d = 0; while (o = p [d ++]) if (r && - 1 <k.inArray (o, r)) i && i.push (o); khác if (l = oe (o), a = ve (f.appendChild (o), "script"), l && ye (a), n) {c = 0; while (o = a [c ++]) he.test (o.type || "") && n.đẩy (o)} return f} me = E.createDocumentFragment (). appendChild (E.createEuity ("div")), (xe = E.createEuity ("input")). setAttribution ("type", "radio" ), xe.setAttribution ("kiểm tra", "đã kiểm tra"), xe.setAttribution ("name", "t"), me.appendChild (xe), y.checkClone = me.cloneNode (! 0) .cloneNode (! 0) .lastChild.checked, me.innerHTML = "<textarea> x </ textarea>", y.noCloneChecked = !! / ^ (?: mouse|pulum|contextmenu|drag|drop) | click /, ee / / ^ ([^. [*) ((:.). (. +) |) /; 0} function Se () {return! 1} function Ne (e, t) {return e === function () {thử {return E.activeEuity} Catch (e) {}} () == ("tập trung" === t)} chức năng Ae (e, t, n, r, i, o) {var a, s; if ("object" == typeof t) {for (s trong "chuỗi"! = Typeof n && ( r = r | | n, n = void 0),t) Ae (e, s, n, r, t [s], o); trả về e} if (null == r && null == i? (i = n, r = n = void 0): null == i && ("chuỗi" == typeof n? (i = r, r = void 0) :( i = r, r = n, n = void 0)),! 1 === i) i = Se; other if ( ! i) return e; return 1 === o && (a = i, (i = function (e) {return k (). off (e), a.apply (this, argument)}). guide = a. guide | | (a.guid = k.guid ++)), e.each (function () {k.event.add (this, t, i, r, n)})} Hàm De (e, i, o) {o? (Q.set (e, i ,! 1), k.event.add (e, i, {không gian tên :! 1, handler: function (e) {var t, n, r = Q.get ( this, i); if (1 & e.isTrigger && this [i]) {if (r.length) (k.event.special [i] || {}). ủy nhiệmType && e.stopPropagation (); (đối số), Q.set (this, i, r), t = o (this, i), this [i] (), r! == (n = Q.get (this, i)) || t ? Q.set (this, i ,! 1): n = {}, r! == n) return e.stopImmediatePropagation (), e.preventDefault (), n.value} khác r.length && (Q.set ( này, i, {value: k.event.trigger (k.extend (r [0], k.Event.prototype), r.lát (1), cái này)}), e.stopImmediatePropagation ())}})): void 0 === Q.get (e, i) && k.event.add (e, i, ke)} k.event = {toàn cầu: {}, thêm: hàm (t, e, n, r, i) {var o, a, s, u, l, c, f, p, d, h, g, v = Q.get (t); if (v) {n.handler && (n = (o = n) .handler, i = o.selector), i && k.find.matchesSelector (tức là i), n.guid || (n.guid = k.guid ++), (u = v.events) || (u = v.events = {}), (a = v.handle) || (a = v.handle = function (e) {return "không xác định "! = typeof k && k.event.triggered! == e.type? k.event.dispatch.apply (t, argument): void 0}), l = (e = (e ||" "). khớp (R ) || [""]). chiều dài; while (l -) d = g = (s = Ee.exec (e [l]) || []) [1], h = (s [2] | | ""). split ("."). sort (), d && (f = k.event.special [d] || {}, d = (i? f.delegateType: f.bindType) || d, f = k.event.special [d] || {}, c = k.extend ({type: d, origType: g, data: r, handler: n, guide: n.guid, selector: i, cầnContext: i && k.expr.match.needContext.test (i),không gian tên: h.join (".")}, o), (p = u [d]) || ((p = u [d] = []). BoulevardateCount = 0, f.setup &&! 1! == f.setup.call (t, r, h, a) || t.addEventListener && t.addEventListener (d, a)), f.add && (f.add.call (t, c), c.handler.guid || (c.handler.guid = n.guid)), i? p.splice (p.delegateCount ++, 0, c): p.push (c), k.event.global [d] =! 0)}}, xóa: hàm (e, t, n, r, i) {var o, a, s, u, l, c, f, p, d, h, g, v = Q.hasData (e) && Q.get ( e); if (v && (u = v.events)) {l = (t = (t || ""). match (R) || [""]). length; while (l -) if ( d = g = (s = Ee.exec (t [l]) || []) [1], h = (s [2] || ""). split ("."). sort (), d ) {f = k.event.special [d] || {}, p = u [d = (r? f.delegateType: f.bindType) || d] || [], s = s [2] && new RegExp ("(^ | \\.)" + H.join ("\\. (?:. * \\. |)") + "(\\. | $)"), A = o = p. độ dài; while (o -) c = p [o],! i && g! == c.origType || n && n.guid! == c.guid || s &&! s.test (c.không gian tên) || r && r! == c.selector && ("**"! == r ||! c.selector) || (p.splice (o, 1), c.selector && p.delegateCount -, f.remove && f .remove.call (e, c)); a &&! p.length && (f.teardown &&! 1! == f.teardown.call (e, h, v.handle) || k.removeEvent (e, d, v, .handle), xóa u [d])} khác cho (d in u) k.event.remove (e, d + t [l], n, r ,! 0); k.isEmptyObject (u) && Q.remove (e, "xử lý các sự kiện")}}, Clark: function (e) {var t, n, r, i, o, a, s = k.event.fix (e), u = new Array (argument.length ), l = (Q.get (này, "sự kiện") || {}) [s.type] || [], c = k.event.special [s.type] || {}; for (u [0] = s, t = 1; t <argument.length; t ++) u [t] = argument [t]; if (s.delegateTarget = this ,! C.preDispatch ||! 1! == c.preDispatch .call (this, s)) {a = k.event.handlers.call (this, s, l), t = 0; while ((i = a [t ++]) &&! s.isPropagationStopped ()) {s .cienTarget = i.elem, n = 0; while ((o = i.handlers [n ++]) &&! s.isImmediatePropagationStopped ()) s.rnamespace &&! 1! == o.namespace &&! s.rnamespace.test (o.namespace) || (s.handleOb = dữ liệu, void 0! == (r = ((k.event.special [o.origType] || {}). xử lý || o.handler) .apply (i.elem, u)) &&! 1 == = (s.result = r) && (s.preventDefault (), s.stopPropagation ()))} return c.postDispatch && c.postDispatch.call (this, s), s.result}}, handlers: function (e, t) {var n, r, i, o, a, s = [], u = t.delegateCount, l = e.target; if (u && l.nodeType &&! ("click" === e.type && 1 <= e .button)) cho (; l! == this; l = l.parentNode || this) if (1 === l.nodeType && ("click"! == e.type ||! 0! == l. bị vô hiệu hóa)) {for (o = [], a = {}, n = 0; n <u; n ++) void 0 === a [i = (r = t [n]). selector + ""] && ( a [i] = r.needContext? -1 <k (i, this) .index (l): k.find (i, this, null, [l]). length), a [i] && o.push ( r); o.length && s.push ({elem: l, handlers: o})} return l = this, u <t.length && s.push ({elem: l, handlers: t.slice (u)}), s}, addProp: (t, e) {Object.defineProperty (k.Event.prototype, t, {enumerable :! 0, có thể định cấu hình :! 0, get: m (e)? function () {if (this.origenEvent) .origenEvent)}: function () {if (this.origenEvent) trả lại this.origenEvent [t]}, set: function (e) {Object.defineProperty (this, t, {enumerable :! 0, configureable :! 0, writable :! 0, value: e})}})}, fix: function (e) {return e [k.Exando]? e: new k.Event (e)}, đặc biệt: {load: {noBubble:! 0}, nhấp: {setup: function (e) {var t = this || e; return pe.test (t.type) && t.click && A (t, "input") && De (t, "click", ke) ,! 1}, kích hoạt: function (e) {var t = this || e; return pe.test (t.type) && t.click && A (t, "input") && De (t, "click"),! 0 }, _ mặc định: hàm (e) {var t = e.đích; trả về pe.test (t.type) && t.click && A (t, "input") && Q.get (t, "click") || A (t, "a")}}, beforeunload: {postDispatch: function (e) {void 0! == e.result && e.origenEvent && (e.origenEvent.returnValue = e.result)}}}}, k.removeEvent = function (e, t, n) {e.removeEventListener & eener , n)}, k.Event = function (e, t) {if (! (ví dụ này k.Event)) trả về k.Event mới (e, t); e && e.type? (this.origenEvent = e, this .type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented &&! 1 === e.returnValue? ke: Se, this.target = e.target && 3 === .nodeType? e.target.parentNode: e.target, this.cienTarget = e.cienTarget, this.relatedTarget = e.relatedTarget): this.type = e, t && k.extend (this, t), this.timeStamp = e && .timeStamp | | Date.now (), [k.Exando] =!0}, k.Event.prototype = {constructor: k.Event, isDefaultPrevented: Se, isPropagationStopped: Se, isImmediatePropagationStopped: Se, isSimined :! 1, notifyDefault: function () ke, e &&! this.isSimulation && e.preventDefault ()}, stopPropagation: function () {var e = this.origenEvent; this.isPropagationStopped = ke, e &&! this.isSimulation && e.stopPropated e = this.origenEvent; this.isImmediatePropagationStopped = ke, e &&! this.isSimulation && e.stopImmediatePropagation (), this.stopPropagation ()}}, k.each ({altKey: 0! đã thay đổiTouches :! 0, ctrlKey :! 0, chi tiết :! 0, eventPhase :! 0, metaKey :! 0, pageX :! 0, pageY :! 0, shiftKey :! 0, view :! 0, "char":! 0, mã :! 0, charCode :! 0, key :! 0, keyCode :! 0, nút :! 0, các nút :! 0, clientX :! 0, clientY :! 0, offsetX :! 0,offsetY :! 0, con trỏId :! 0, con trỏType :! 0, screenX :! 0, screenY :! 0, targetTouches :! 0, toEuity :! 0, chạm :! 0, which: function (e) {var t = e.button; return null == e.which && Te.test (e.type)? null! = e.charCode? e.charCode: e.keyCode :! e.which && void 0! == t && Ce.test (e.type) ? 1 & t? 1: 2 & t? 3: 4 & t? 2: 0: e.which}}, k.event.addProp), k.each ({tập trung: "tập trung", làm mờ: "tập trung"}, hàm (e, t) {k.event.special [e] = {setup: function () {return De (this, e, Ne),! 1}, trigger: function () {return De (this, e) ,! 0} , BoulevardateType: t}}), k.each ({mouseenter: "mouseover", mouseleave: "mouseout", con trỏ: "con trỏ", con trỏ: "con trỏ"}, hàm (e, i) {k.event.special [e] = {BoulevardateType: i, bindType: i, xử lý: function (e) {var t, n = e.relatedTarget, r = e.handleObj; return n && (n === this || k.contains (this , n)) | | (e.type = r.origType, t = r.handler.apply (this, argument), e.type = i), t}}}), k.fn.extend ({on: function (e, t, n, r) {return Ae (this, e, t, n, r)}, one: function (e, t, n, r) {return Ae (this, e, t, n, r, 1)}, off: function (e, t, n) {var r, i; if (e && e.preventDefault && e.handleObj) return r = e.handleObj, k (e.delegateTarget) .off (r.namespace? r.orig "." + r.namespace: r.origType, r.selector, r.handler), this; if ("object" == typeof e) {for (i in e) this.off (i, t, e [ i]); trả lại cái này} return! 1! == t && "function"! = typeof t || (n = t, t = void 0),! 1 === n && (n = Se), this.each ( function () {k.event.remove (this, e, n, t)})}}); var je = / <(?! khu vực | br | col | embed | hr | img | input | link | meta | param) (([az] [^ \ / \ 0> \ x20 \ t \ r \ n \ f] *) [^>] *) \ /> / gi, qe = / <script | <style | <link / i,Le=/checked\s*(?:[ucci=[|=\s*.checked.)/i,He=/ucci\s*<!(?:\[CDATA\[|--) | (?: \] \] | -)> \ s * $ / g; hàm Oe (e, t) {return A (e, "bảng") && A (11! == t.nodeType? t: t .firstChild, "tr") && k (e) .children ("tbody") [0] || e} chức năng Pe (e) {return e.type = (null! == e.getAttribution ("type")) + "/" + e.type, e} chức năng Re (e) {return "true /" === (e.type || "") .slice (0,5)? e.type = e.type.slice (5): e.removeAttribution ("type"), e} chức năng Me (e, t) {var n, r, i, o, a , s, u, l; if (1 === t.nodeType) {if (Q.hasData (e) && (o = Q.access (e), a = Q.set (t, o), l = o.events)) cho (i trong xóa a.handle, a.events = {}, l) for (n = 0, r = l [i] .length; n <r; n ++) k.event.add ( t, i, l [i] [n]); J.hasData (e) && (s = J.access (e), u = k.extend ({}, s), J.set (t, u) )}} Hàm Ie (n, r, i, o) {r = g.apply ([], r); var e, t, a, s, u, l, c = 0, f = n.length, p = f-1, d = r [0], h = m (d); if (h | | 1 <f && "chuỗi" == typeof d &&! y.checkClone && Le.test (d)) return n.each ( hàm (e) {var t = n.eq (e); h && (r [0] = d.call (này, e, t.html ())), tức là (t, r, i, o)}) ; if (f && (t = (e = we (r, n [0] .ownerDocument ,! 1, n, o)). FirstChild, 1 === e.childNodes.chiều dài && (e = t), t || o)) {for (s = (a = k.map (ve (e, "script"), Pe)). length; c <f; c ++) u = e, c! == p && (u = k.clone (u ,! 0 ,! 0), s && k.merge (a, ve (u, "script"))), i.call (n [c], u, c ); if (s) for (l = a [a.length-1] .ownerDocument, k.map (a, Re), c = 0; c <s; c ++) u = a [c], he.test (u.type || "") &&! Q.access (u, "globalEval") && k.contains (l, u) && (u.src && "module"! == (u.type || ""). toLowerCase ()? k._evalUrl &&! u.noModule && k._evalUrl (u.src, {nonce: u.nonce || u.getAttribution ("nonce")}): b (u.textContent.re , u, l))} return n} hàm We (e, t, n) {for (var r, i = t? k.filter (t, e): e, o = 0; null! = (r = i [o]); o ++) n || 1! == r.nodeType || k.cleanData (ve (r)), r.parentNode && (n && oe (r) && ye (ve (r, "script")), r.parentNode.removeChild (r)); return e} k.extend ({htmlPrefilter: function (e) {return e.replace (je, "<$ 1> </ $ 2>")}, clone: ​​function (e, t, n) {var r, i, o, a, s , u, l, c = e.cloneNode (! 0), f = oe (e); if (! (y.noCloneChecked || 1! == e.nodeType && 11! == e.nodeType || k.isXMLDoc ( e))) cho (a = ve (c), r = 0, i = (o = ve (e)). length; r <i; r ++) s = o [r], u = a [r], void 0, "input" === (l = u.nodeName.toLowerCase ()) && pe.test (s.type)? u.checked = s.checked: "input"! == l && "textarea"! == l || (u.defaultValue = s.defaultValue); if (t) if (n) cho (o = o | | ve (e), a = a | | ve (c), r = 0, i = o .length; r <i; r ++) Me (o [r], a [r]); other Me (e, c); return 0 <(a = ve (c, "script")). length && ye (a, ! f && ve (e, "script")), c}, cleanData: function (e) {for (var t, n, r, i = k.event.special, o = 0; void 0! == (n = e [o]); o ++) if (G (n)) {if (t = n [Q.Exando]) {if (t.events) cho (r in t.events) i [r]? k.event .remove (n, r): k.removeEvent (n, r, t.xử lý); n [Q.Exando] = void 0} n [J.Exando] && (n [J.Exando] = void 0)}}}), k.fn.extend ({detach: function (e) { return We (this, e ,! 0)}, remove: function (e) {return We (this, e)}, text: function (e) {return _ (this, function (e) {return void 0 == = e? k.text (this): this.empty (). Each (function () {1! == this.nodeType && 11! == this.nodeType && 9! == this.nodeType || (this.textContent = e) })}, null, e, argument.length)}, append: function () {return Ie (this, argument, function (e) {1! == this.nodeType && 11! == this.nodeType && 9! == this. nodeType | | Oe (this, e) .appendChild (e)})}, Prepend: function () {return Ie (this, argument, function (e) {if (1 === this.nodeType || 11 == = this.nodeType || 9 === this.nodeType) {var t = Oe (this, e); t.insertB Before (e, t.firstChild)}})}, before: function () {return Ie (this , đối số, hàm (e) {this.parentNode && this.parentNode.insertB Before (e, this)})}, sau:function () {return Ie (this, argument, function (e) {this.parentNode && this.parentNode.insertB Before (e, this.nextSibling)})}, blank: function () {for (var e, t = 0; null ! = (e = this [t]); t ++) 1 === e.nodeType && (k.cleanData (ve (e ,! 1)), e.textContent = ""); trả lại cái này}, clone: ​​function ( e, t) {return e = null! = e && e, t = null == t? e: t, this.map (function () {return k.clone (this, e, t)})}, html: function (e) {return _ (this, function (e) {var t = this [0] || {}, n = 0, r = this.length; if (void 0 === e && 1 === t.nodeType ) trả về t.innerHTML; if ("chuỗi" == typeof e &&! qe.test (e) &&! ge [(de.exec (e) || ["", ""]) [1] .toLowerCase () ]) {e = k.htmlPrefilter (e); thử {for (; n <r; n ++) 1 === (t = this [n] | | {}). nodeType && (k.cleanData (ve (t, ! 1)), t.innerHTML = e); t = 0} Catch (e) {}} t && this.empty (). Append (e)}, null, e, argument.length)}, thayWith:function () {var n = []; return Ie (this, argument, function (e) {var t = this.parentNode; k.inArray (this, n) <0 && (k.cleanData (ve (this)), t && t.replaceChild (e, this))}, n)}}), k.each ({appendTo: "append", preendTo: "preend", insertB Before: "before", insertAfter: "after", thay ALL: " "}, Hàm (e, a) {k.fn [e] = function (e) {for (var t, n = [], r = k (e), i = r.length-1, o = 0 ; o <= i; o ++) t = o === i? this: this.clone (! 0), k (r [o]) [a] (t), u.apply (n, t.get ( )); return this.pushStack (n)}}); var $ e = new RegExp ("^ (" + te + ") (?! px) [az%] + $", "i"), Fe = function (e) {var t = e.ownerDocument.defaultView; return t && t.opener || (t = C), t.getComputingStyle (e)}, Be = new RegExp (re.join ("|"), "i" ); hàm _e (e, t, n) {var r, i, o, a, s = e.style; return (n = n || Fe (e)) && (""! == (a = n .getPropertyValue (t) || n [t]) || oe (e) || (a = k.style (e, t)) ,! y.pixelBoxStyles () && $ e.test (a) && Be.test ( t) && (r = s. thong, i = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s. thong = a, a = n. thong, s. thong = r, s. minWidth = i, s.maxWidth = o)), void 0! == a? a + "": a} chức năng ze (e, t) {return {get: function () {if (! e ()) return ( this .get = t) .apply (this, argument); xóa this.get}}}! function () {function e () {if (u) {s.style.cssText = "location: perfect; left: - 11111px; width: 60px; margin-top: 1px; padding: 0; Border: 0 ", u.style.cssText =" vị trí: tương đối; display: block; box-sizing: Border-box; overflow: scroll; lề: lề: auto; Border: 1px; padding: 1px; width: 60%; top: 1% ", tức là.appendChild (s) .appendChild (u); var e = C.getComputingStyle (u); n =" 1% "! == e.top, a = 12 === t (e.marginLeft), u.style.right = "60%", o = 36 === t (e.right), r = 36 === t (e. thong), u.style.poseition = "tuyệt đối ", i = 12 === t (u.offsetWidth / 3), tức là.removeChild (s), u = null}} chức năng t (e) {return Math.round (parseFloat (e))} var n, r, i, o, a, s = E.createEuity ("div"), u = E.createEuity ("div"); u.style && (u.style.backgroundClip = "box-box", u.cloneNode ( ! 0) .style.backgroundClip = "", y.clearCloneStyle = "content-box" === u.style.backgroundClip, k.extend (y, {boxSizingReliable: function () {return e (), r}, pixelBoxStyles: function () {return e (), o}, pixelPocation: function () {return e (), n}, TrustedMarginLeft: function () {return e (), a}, scrollboxSize: function () {return e (), i}}))} (); var Ue = ["Webkit", "Moz", "ms"], Xe = E.createEuity ("div"). style, Ve = {}; function Ge ( e) {var t = k.cssProps [e] | | Ve [e]; return t || (e trong Xe? e: Ve [e] = function (e) {var t = e [0] .toUpperCase ( ) + e.slice (1), n ​​= Ue.length;while (n -) if ((e = Ue [n] + t) trong Xe) return e} (e) || e)} var Ye = / ^ (none | bảng (?! - c [e]) . +) /, Qe = / ... ; hàm Ze (e, t, n) {var r = ne.exec (t); return r? Math.max (0, r [2] - (n | | 0)) + (r [3] || "px"): t} chức năng et (e, t, n, r, i, o) {var a = "width" === t? 1: 0, s = 0, u = 0; if (n = == (r? "viền": "nội dung")) trả về 0; for (; a <4; a + = 2) "lề" === n && (u + = k.css (e, n + re [a] ,! 0, i)), r? ("Nội dung" === n && (u- = k.css (e, "padding" + re [a],! 0, i)), "lề"! == n && (u- = k.css (e, "Border" + re [a] + "Width" ,! 0, i))) :( u + = k.css (e, "padding" + re [a], ! 0, i), "padding"! == n? U + = k.css (e, "Border" + re [a] + "Width" ,! 0, i): s + = k.css (e, "viền "+ re [a] +" Width ",! 0, i)); return! r && 0 <= o && (u + = Math.max (0, Math.ceil (e [" offset "+ t [0] .toUpperCase () + t.slice (1)] - ous-.5)) || 0), u} hàm tt (e, t, n) {var r = Fe (e), i = (! y.boxSizingReliable ( ) || n) && "hộp viền" === k.css (e, "boxSizing" ,! 1, r), o = i, a = _e (e, t, r), s = "offset" + t [0] .toUpperCase () + t.slice (1); if ($ e.test (a)) {if (! n) return a; a = "auto"} return (! y.boxSizingReliable () && i || "auto" === a ||! parseFloat (a) && "inline" === k.css (e, "display" ,! 1, r)) && e.getClientRects (). length && (i = "hộp viền" === k.css (e, "boxSizing" ,! 1, r), (o = s in e) && (a = e [s])), (a = parseFloat (a) | | 0) + et (e, t, n || (i? "Đường viền": "nội dung"), o, r, a) + "px"} hàm nt (e, t, n, r, i) { trả về nt.prototype.init mới (e, t, n, r,i)} k.extend ({cssHooks: {opacity: {get: function (e, t) {if (t) {var n = _e (e, "opacity"); return "" === n? "1 ": n}}}}, cssNumber: {animationIterationCount :! 0, cộtCount :! 0, fillOpacity :! 0, flexGrow :! 0, flexShrink :! 0, font Weight :! 0, GridArea :! 0, GridColumn :! , GridColumnEnd :! 0, GridColumnStart :! 0, GridRow :! 0, GridRowEnd :! 0, GridRowStart :! 0, lineHeight :! 0, opacity :! 0, order :! 0, orphans :! , z Index :! 0, zoom :! 0}, cssProps: {}, style: function (e, t, n, r) {if (e && 3! == e.nodeType && 8! == e.nodeType && e.style) {var i, o, a, s = V (t), u = Qe.test (t), l = e.style; if (u || (t = Ge (s)), a = k.cssHooks [t] || k.cssHooks [s], void 0 === n) trả lại một && "get" trong một && void 0! == (i = a.get (e ,! 1, r))? i: l [t]; "chuỗi" === (o = typeof n) && (i = ne.exec (n)) && i [1] && (n = le (e, t, i), o = "number"), null! = n && n == n && ("số "! == o || u || (n + = i && i [3] || (k.cssNumber [s]?" ":" px ")), y.clearCloneStyle ||" "! == n || 0! == t.indexOf ("nền") || (l [t] = "thừa kế"), a && "set" trong a && void 0 === (n = a.set (e, n, r)) | | (u? l.setProperty (t, n): l [t] = n))}}, css: function (e, t, n, r) {var i, o, a, s = V (t) ; trả về Qe.test (t) || (t = Ge (s)), (a = k.cssHooks [t] || k.cssHooks [s]) && "get" trong a && (i = a.get ( e ,! 0, n)), void 0 === i && (i = _e (e, t, r)), "bình thường" === i && t trong Ke && (i = Ke [t]), "" == = n || n? (o = parseFloat (i),! 0 === n | | isFinite (o)? o || 0: i): i}}), k.each (["height", " width "], function (e, u) {k.cssHooks [u] = {get: function (e, t, n) {if (t) return! Ye.test (k.css (e," display ") ) || e.getClientRects (). length && e.getBoundingClientRect (). width? tt (e, u, n): ue (e, Je,hàm () {return tt (e, u, n)})}, set: function (e, t, n) {var r, i = Fe (e), o =! y.scrollboxSize () && "tuyệt đối" === i.poseition, a = (o || n) && "hộp viền" === k.css (e, "boxSizing" ,! 1, i), s = n? Et (e, u, n, a, i): 0; trả về a && o && (s- = Math.ceil (e ["offset" + u [0] .toUpperCase () + u.slice (1)] - parseFloat (i [u]) - et (e, u, "viền" ,! 1, i) -. 5)), s && (r = ne.exec (t)) && "px"! == (r [3] || "px") && (e.style [u] = t, t = k.css (e, u)), Ze (0, t, s)}}}), k.cssHooks.marginLeft = ze (y.reliableMarginLeft, function ( e, t) {if (t) return (parseFloat (_e (e, "marginLeft")) || e.getBoundingClientRect (). left-ue (e, {marginLeft: 0}, function () {return e.getBoundingClient () .left})) + "px"}), k.each ({lề: "", đệm: "", đường viền: "Chiều rộng"}, hàm (i, o) {k.cssHooks [i + o ] = {mở rộng:hàm (e) {for (var t = 0, n = {}, r = "chuỗi" == typeof e? e.split (""): [e]; t <4; t ++) n [i + re [t] + o] = r [t] || r [t-2] || r [0]; return n}}, "lề"! == i && (k.cssHooks [i + o] .set = Ze)}), k.fn.extend ({css: function (e, t) {return _ (this, function (e, t, n) {var r, i, o = {}, a = 0; if (Array.isArray (t)) {for (r = Fe (e), i = t.length; a <i; a ++) o [t [a]] = k.css (e, t [a],! 1, r); return o} return void 0! == n? K.style (e, t, n): k.css (e, t)}, e, t, 1 <argument.length)}}) , ((k.Tween = nt) .prototype = {constructor: nt, init: function (e, t, n, r, i, o) {this.elem = e, this.prop = n, this.ease = i | | k.ease._default, this.options = t, this.start = this.now = this.cur (), this.end = r, this.unit = o || (k.cssNumber [n]? "": "px")}, cur: function () {var e = nt.propHooks [this.prop]; return e && e.get? e.get (this): nt.propHooks._default.get (this)} , run: function (e) {var t, n = nt.propHooks [this.prop]; trả lại cái này.Options.duration? this.pose = t = k.ease [this.ease] (e, this.options.duration * e, 0,1, this.options.duration): this.pose = t = e, this. now = (this.end-this.start) * t + this.start, this.options.step && this.options.step.call (this.elem, this.now, this), n && n.set? n.set (this ): nt.propHooks._default.set (this), this}}). init.prototype = nt.prototype, (nt.propHooks = {_ default: {get: function (e) {var t; return 1! == e.elem.nodeType || null! = e.elem [e.prop] && null == e.elem.style [e.prop]? e.elem [e.prop] :( t = k.css (e. elem, e.prop, "")) && "auto"! == t? t: 0}, set: function (e) {k.fx.step [e.prop]? k.fx.step [e. prop] (e): 1! == e.elem.nodeType ||! k.cssHooks [e.prop] && null == e.elem.style [Ge (e.prop)]? e.elem [e.prop ] = e.now: k.style (e.elem, e.prop, e.now + e.unit)}}}). scrollTop = nt.propHooks.scrollLeft = {set: function (e) {e.elem .nodeType && e.elem.parentNode && (e.elem [e.prop] = e.now)}}, k.ease = {linear: function (e) {return e}, swing: function (e) {return.5-Math.cos (e * Math.PI ) / 2}, _ default: "swing"}, k.fx = nt.prototype.init, k.fx.step = {}; var rt, it, ot, at, st = / ^ (?: Chuyển đổi | hiển thị | ẩn) $ /, ut = / queueHooks $ /; function lt () {it && (! 1 === E.hidden && C.requestAnimationFrame? C.requestAnimationFrame (lt): C.setTimeout (lt, k.fx.inter) , k.fx.tick ())} chức năng ct () {return C.setTimeout (function () {rt = void 0}), rt = Date.now ()} chức năng ft (e, t) {var n, r = 0, i = {height: e}; for (t = t? 1: 0; r <4; r + = 2-t) i ["lề" + (n = re [r])] = i [ "padding" + n] = e; return t && (i.opacity = i. thong = e), i} hàm pt (e, t, n) {for (var r, i = (dt.tweeners [t] | | []). concat (dt.tweeners ["*"]), o = 0, a = i.length; o <a; o ++) if (r = i [o] .call (n, t, e) ) trả về hàm r} dt (o, e, t) {var n, a, r = 0, i = dt.prefilters.length, s = k.Deferred (). always (function () {xóa u.elem}), u = function () {if (a) return! 1; for (var e = rt || ct (), t = Math.max (0, l.startTime + l.duration-e), n = 1- (t / l.duration || 0), r = 0, i = l.tweens.length; r <i; r ++) l.tweens [r] .run (n); return s.notifyWith (o , [l, n, t]), n <1 && i? t: (i | | s.notifyWith (o, [l, 1,0]), s.resolveWith (o, [l]),! 1)} , l = s.promise ({elem: o, props: k.extend ({}, e), opts: k.extend (! 0, {SpecialEasing: {}, nới lỏng: k.ease._default}, t) , gốcProperies: e, originalOptions: t, startTime: rt || ct (), thời lượng: t.duration, twges: [], createdTween: function (e, t) {var n = k.Tween (o, l.opts , e, t, l.opts.specialEasing [e] || l.opts.ease); return l.tweens.push (n), n}, stop: function (e) {var t = 0, n = e ? l.tweens.length: 0; if (a) trả lại cái này; for (a =! 0; t <n; t ++) l.tweens [t] .run (1); return e? (s.notifyWith (o , [l, 1,0]), s.resolveWith (o, [l, e])): s.rejectWith (o, [l, e]), this}}), c = l.props; for ( ! hàm (e, t) {var n, r, i, o, a; for (n in e) if (i = t [r = V (n)], o = e [n], Array.isArray (o) && (i = o [1], o = e [n] = o [0]), n! == r && (e [r] = o, xóa e [n]), (a = k .cssHooks [r]) && "bung rộng" trong a) cho (n in o = a.Exand (o), xóa e [r], o) n trong e || (e [n] = o [n], t [n] = i); other t [r] = i} (c, l.opts.specialEasing); r <i; r ++) if (n = dt.prefilters [r] .call (l, o, c , l.opts)) return m (n.stop) && (k._queueHooks (l.elem, l.opts.queue) .stop = n.stop.bind (n)), n; return k.map (c , pt, l), m (l.opts.start) && l.opts.start.call (o, l), l.proTHER (l.opts.proTHER) .done (l.opts.done, l.opts. hoàn thành) .fail (l.opts.fail) .always (l.opts.always), k.fx.timer (k.extend (u, {elem: o, anim: l, queue: l.opts.queue} )), l} k.Animation = k.extend (dt, {tweeners: {"*": [function (e, t) {var n = this.createTween (e, t); return le (n.elem, e, ne.exec (t), n), n}]}, tweener: function (e, t) {m (e)? (t = e, e = ["*"]): e = e.match (R); for (var n, r = 0, i = e.length; r <i; r ++) n = e [r], dt.tweeners [n] = dt.tweeners [n] || [], dt.tweeners [n] .unshift (t)}, prefilters: [function (e, t, n) {var r, i, o, a, s, u, l, c , f = "width" tính bằng t || "height" trong t, p = this, d = {}, h = e.style, g = e.nodeType && se (e), v = Q.get (e, "fxshow "); for (r in n.queue || (null == (a = k._queueHooks (e," fx ")). unqueued && (a.unqueued = 0, s = a.empty.fire, a.empty .fire = function () {a.unqueued || s ()}), a.unqueued ++, p.always (function () {p.always (function () {a.unqueued -, k.queue (e, "fx"). length || a.empty.fire ()})})), t) if (i = t [r], st.test (i)) {if (xóa t [r], o = o || "chuyển đổi" === i, i === (g? "ẩn": "hiển thị")) {if ("hiển thị"! == i | |! v || void 0 === v [ r]) tiếp tục; g =! 0} d [r] = v && v [r] | | k.style (e, r)} if ((u =! k.isEmptyObject (t)) ||! k.isEmptyObject ( d)) cho (r trong f && 1 === e.nodeType && (n.overflow = [h.overflow, h.overflowX, h.overflowY], null == (l = v && v.hiển thị) && (l = Q.get (e, "display")), "none" === (c = k.css (e, "display")) && (l? c = l: (fe ([ e],! 0), l = e.style.display || l, c = k.css (e, "display"), fe ([e]))), ("nội tuyến" === c || "khối nội tuyến" === c && null! = l) && "none" === k.css (e, "float") && (u || (p.done (function () {h.display = l} ), null == l && (c = h.display, l = "none" === c? "": c)), h.display = "inline-block")), n.overflow && (h.overflow = "hidden", p.always (function () {h.overflow = n.overflow [0], h.overflowX = n.overflow [1], h.overflowY = n.overflow [2]})), u = ! 1, d) u || (v? "Ẩn" trong v && (g = v.hidden): v = Q.access (e, "fxshow", {display: l}), o && (v.hidden =! g), g && fe ([e],! 0), p.done (function () {for (r in g | | fe ([e]), Q.remove (e, "fxshow"), d) k. phong cách (e, r,d [r])})), u = pt (g? v [r]: 0, r, p), r trong v | | (v [r] = u.start, g && (u.end = u. start, u.start = 0))}], prefilter: function (e, t) {t? dt.prefilters.unshift (e): dt.prefilters.push (e)}}), k.speed = function ( e, t, n) {var r = e && "object" == typeof e? k.extend ({}, e): {hoàn thành: n ||! n && t || m (e) && e, thời lượng: e, nới lỏng : n && t || t &&! m (t) && t}; return k.fx.off?r.duration=0:"number"!=typeof r.duration && (r.duration trong k.fx.speed? r.duration = k.fx.speed [r.duration]: r.duration = k.fx.speed._default), null! = r.queue &&! 0! == r.queue || (r.queue = "fx"), r.old = r.complete, r.complete = function () {m (r.old) && r.old.call (this), r.queue && k.dequeue (this, r.queue)}, r}, k. fn.extend ({fadeTo: function (e, t, n, r) {return this.filter (se) .css ("opacity", 0) .show (). end (). animate ({opacity: t} , e, n, r)}, animate: hàm (t, e, n,r) {var i = k.isEmptyObject (t), o = k.speed (e, n, r), a = function () {var e = dt (this, k.extend ({}, t), o ); (i | | Q.get (này, "kết thúc")) && e.stop (! 0)}; trả lại a.finish = a, i | |! 1 === o.queue? this.each (a ): this.queue (o.queue, a)}, stop: function (i, e, o) {var a = function (e) {var t = e.stop; xóa e.stop, t (o)} ; trả về "chuỗi"! = typeof i && (o = e, e = i, i = void 0), e &&! 1! == i && this.queue (i || "fx", []), this.each (hàm () {var e =! 0, t = null! = i && i + "queueHooks", n = k.timers, r = Q.get (this); if (t) r [t] && r [t] .stop && a (r [t]); khác cho (t in r) r [t] && r [t] .stop && ut.test (t) && a (r [t]); for (t = n.length; t -;) n [ t] .elem! == this || null! = i && n [t] .queue! == i || (n [t] .anim.stop (o), e =! 1, n.splice (t, 1 ));! e && o || k.dequeue (this, i)})}, finish: function (a) {return! 1! == a && (a = a || "fx"), cái này.mỗi (hàm () {var e, t = Q.get (this), n = t [a + "queue"], r = t [a + "queueHooks"], i = k.timers, o = n? n. độ dài: 0; for (t.finish =! 0, k.queue (this, a, []), r && r.stop && r.stop.call (this ,! 0), e = i.length; e--;) i [e] .elem === this && i [e] .queue === a && (i [e] .anim.stop (! 0), i.splice (e, 1)); for (e = 0; e <o; e ++) n [e] && n [e] .finish && n [e] .finish.call (this); xóa t.finish})}}), k.each (["chuyển đổi", "hiển thị", " ẩn "], hàm (e, r) {var i = k.fn [r]; k.fn [r] = function (e, t, n) {return null == e ||" boolean "== typeof e? i.apply (this, argument): this.animate (ft (r ,! 0), e, t, n)}}), k.each ({slideDown: ft ("show"), slideUp: ft ("ẩn"), slideToggle: ft ("toggle"), fadeIn: {opacity: "show"}, fadeOut: {opacity: "hide"}, fadeToggle: {opacity: "toggle"}}, function (e, r) {k.fn [e] = function (e, t, n) {return this.animate (r, e, t, n)}}), k.timers = [], k.fx.tick = function () {var e , t = 0, n = k.timers; for (rt = Date.now (); t <n.length; t ++) (e = n [t]) () || n [t]! == e | | n.splice (t -, 1); n.length || k.fx.stop (), rt = void 0}, k.fx.timer = function (e) {k.timers.push (e) , k.fx.start ()}, k.fx.interval = 13, k.fx.start = function () {it || (it =! 0, lt ())}, k.fx.stop = function () {it = null}, k.fx.speed = {Slow: 600, fast: 200, _default: 400}, k.fn.delay = function (r, e) {return r = k.fx && k.fx. speed [r] | | r, e = e || "fx", this.queue (e, function (e, t) {var n = C.setTimeout (e, r); t.stop = function () { C.clearTimeout (n)}})}, ot = E.createEuity ("input"), at = E.createEuity ("select"). AppendChild (E.createEuity ("tùy chọn")), ot.type = " hộp kiểm ", y.checkOn =" "! == ot.value, y.optSelected = at.selected, (ot = E.createEuity (" input ")). value =" t ", ot.loại = "radio", y.radioValue = "t" === ot.value; var ht, gt = k.expr.attrHandle; k.fn.extend ({attr: function (e, t) {return _ ( this, k.attr, e, t, 1 <argument.length)}, removeAttr: function (e) {return this.each (function () {k.removeAttr (this, e)})}}), k. mở rộng ({attr: function (e, t, n) {var r, i, o = e.nodeType; if (3! == o && 8! == o && 2! == o) trả về "không xác định" == typeof e. getAttribution? k.prop (e, t, n) :( 1 === o && k.isXMLDoc (e) || (i = k.attrHooks [t.toLowerCase ()] || (k.expr.match.bool. test (t)? ht: void 0)), void 0! == n? null === n? void k.removeAttr (e, t): i && "set" trong i && void 0! == (r = i. đặt (e, n, t))? r: (e.setAttribution (t, n + ""), n): i && "get" trong i && null! == (r = i.get (e, t))? r : null == (r = k.find.attr (e, t))? void 0: r)}, attrHooks: {type: {set: function (e, t) {if (! y.radioValue && "radio" === t && A (e, "đầu vào ")) {var n = e.value; return e.setAttribution (" type ", t), n && (e.value = n), t}}}}, removeAttr: function (e, t) {var n , r = 0, i = t && t.match (R); if (i && 1 === e.nodeType) while (n = i [r ++]) e.removeAttribution (n)}}), ht = {set: function ( e, t, n) {return! 1 === t? k.removeAttr (e, n): e.setAttribution (n, n), n}}, k.each (k.expr.match.bool.source .match (/ \ w + / g), hàm (e, t) {var a = gt [t] || k.find.attr; gt [t] = function (e, t, n) {var r, i , o = t.toLowerCase (); return n || (i = gt [o], gt [o] = r, r = null! = a (e, t, n)? o: null, gt [o] = i), r}}); var vt = / ^ (?: input | select | textarea | nút) $ / i, yt = / ^ (?: a | area) $ / i; function mt (e) { return (e.match (R) || []). tham gia ("")} chức năng xt (e) {return e.getAttribution && e.getAttribution ("class") || ""} chức năng bt (e) {return Array .isArray (e)? e: "chuỗi" == typeof e && e.match (R) || []} k.fn.extend ({prop: function (e, t) {return _ (this,k.prop, e, t, 1 <argument.length)}, removeProp: function (e) {return this.each (function () {xóa this [k.propFix [e] || e]})}}) , k.extend ({prop: function (e, t, n) {var r, i, o = e.nodeType; if (3! == o && 8! == o && 2! == o) return 1 === o && k .isXMLDoc (e) || (t = k.propFix [t] || t, i = k.propHooks [t]), void 0! == n? i && "set" trong i && void 0! == (r = i.set (e, n, t))? r: e [t] = n: i && "get" trong i && null! == (r = i.get (e, t))? r: e [t]} , propHooks: {tab Index: {get: function (e) {var t = k.find.attr (e, "tabindex"); return t? parseInt (t, 10): vt.test (e.nodeName) || yt.test (e.nodeName) && e.href? 0: -1}}}, propFix: {"cho": "htmlFor", "class": "className"}}), y.optSelected || (k. propHooks.selected = {get: function (e) {var t = e.parentNode; return t && t.parentNode && t.parentNode.selectedIndex, null}, set:hàm , "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {k.propFix [this.toLowerCase ()] = this}), k.fn.extend ({addClass: function (t) {var e, n, r, i, o, a, s, u = 0; if (m (t)) return this.each (function (e) {k (this). addClass (t.call (this, e, xt (this)))}); if ((e = bt (t)). length) while (n = this [u ++]) if (i = xt (n), r = 1 === n.nodeType && "" + mt (i) + "") {a = 0; while (o = e [a ++]) r.indexOf ("" + o + "") <0 && (r + = o + ""); i! == (s = mt (r)) && n.setAttribution ("class", s)} trả lại cái này}, removeClass: function (t) {var e, n, r, i, o, a, s, u = 0;if (m (t)) return this.each (function (e) {k (this) .removeClass (t.call (this, e, xt (this)))}); if (! argument.length) trả lại .attr ("class", ""); if ((e = bt (t)). length) while (n = this [u ++]) if (i = xt (n), r = 1 === n. nodeType && "" + mt (i) + "") {a = 0; while (o = e [a ++]) while (-1 <r.indexOf ("" + o + "")) r = r.replace (" "+ o +" "," "); i! == (s = mt (r)) && n.setAttribution (" class ", s)} trả lại cái này}, toggleClass: function (i, t) {var o = typeof i, a = "chuỗi" === o || Array.isArray (i); return "boolean" == typeof t && a? t? this.addClass (i): this.removeClass (i): m (i)? this .each (function (e) {k (this) .toggleClass (i.call (this, e, xt (this), t), t)}): this.each (function () {var e, t, n, r; if (a) {t = 0, n = k (this), r = bt (i); while (e = r [t ++]) n.hasClass (e)? n.removeClass (e): n.addClass (e)} khác void 0! == i &&"boolean"! == o || ((e = xt (this)) && Q.set (this, "__ className __", e), this.setAttribution && this.setAttribution ("class", e ||! 1 === i ? "": Q.get (này, "__ className __") || ""))})}, hasClass: function (e) {var t, n, r = 0; t = "" + e + ""; (n = this [r ++]) if (1 === n.nodeType && - 1 <("" + mt (xt (n)) + "") .indexOf (t)) return! 0; return! 1}} ); var wt = / \ r / g; k.fn.extend ({val: function (n) {var r, e, i, t = this [0]; return argument.length? (i = m (n ), this.each (function (e) {var t; 1 === this.nodeType && (null == (t = i? n.call (this, e, k (this) .val ()): n) ? t = "": "number" == typeof t? t + = "": Array.isArray (t) && (t = k.map (t, function (e) {return null == e? "": e + ""})), (r = k.valHooks [this.type] || k.valHooks [this.nodeName.toLowerCase ()]) && "set"trong r && void 0! == r.set (this, t, "value") || (this.value = t))})): t? (r = k.valHooks [t.type] || k.valHooks [t.nodeName.toLowerCase ()]) && "get" trong r && void 0! == (e = r.get (t, "value"))? e: "chuỗi" == typeof (e = t.value) ? e.replace (wt, ""): null == e? "": e: void 0}}), k.extend ({valHooks: {tùy chọn: {get: function (e) {var t = k. find.attr (e, "value"); return null! = t? t: mt (k.text (e))}}, chọn: {get: function (e) {var t, n, r, i = e.options, o = e.selected Index, a = "select-one" === e.type, s = a? null: [], u = a? o + 1: i.length; for (r = o <0? U: a? O: 0; r <u; r ++) if (((n = i [r]). Đã chọn | | r === o) &&! N.disables && (! N.parentNode.disables ||! A (n.parentNode, "optgroup"))) {if (t = k (n) .val (), a) return t; s.push (t)} return s}, set: function (e , t) {var n, r, i = e.options, o = k.makeArray (t), a = i.length; while (a -) ((r = i [a]).đã chọn = -1 <k.inArray (k.valHooks.option.get (r), o)) && (n =! 0); return n || (e.selectedIndex = -1), o}}}}) , k.each (["radio", "hộp kiểm"], function () {k.valHooks [this] = {set: function (e, t) {if (Array.isArray (t)) return e.checked = -1 <k.inArray (k (e) .val (), t)}}, y.checkOn || (k.valHooks [this] .get = function (e) {return null === e.getAttribution ( "giá trị")? "trên": e.value})}), y.f Focusin = "onf Focusin" trong C; var Tt = / ^ (?: Focusinf Focus | Focusoutblur) $ /, Ct = function (e) {e .stopPropagation ()}; k.extend (k.event, {trigger: function (e, t, n, r) {var i, o, a, s, u, l, c, f, p = [n | | E], d = v.call (e, "type")? E.type: e, h = v.call (e, "không gian tên")? E.namespace.split ("."): []; if (o = f = a = n = n || E, 3! == n.nodeType && 8! == n.nodeType &&! tt.test (d + k.event.triggered) && (- 1 <d.indexOf ( ".") && (d = (h = d.split (".")).shift (), h.sort ()), u = d.indexOf (":") <0 && "on" + d, (e = e [k.Exando]? e: đối tượng k.Event (d, "mới "== typeof e && e)). isTrigger = r? 2: 3, e.namespace = h.join (". "), e.rnamespace = e.namespace? new RegExp (" (^ | \.) "+ h.join ("\\. (?:. * \\. |)") + "(\\. | $)"): null, e.result = void 0, e.target || (e.target = n), t = null == t? [e]: k.makeArray (t, [e]), c = k.event.special [d] || {}, r ||! c.trigger | | ! 1! == c.trigger.apply (n, t))) {if (! R &&! C.noBubble &&! X (n)) {for (s = c.delegateType || d, Tt.test (s + d) || (o = o.parentNode); o; o = o.parentNode) p.push (o), a = o; a === (n.ownerDocument || E) && p.push (a.defaultView | | a.parentWindow || C)} i = 0; while ((o = p [i ++]) &&! e.isPropagationStopped ()) f = o, e.type = 1 <i? s: c.bindType | | d, (l = (Q.get (o, "sự kiện") || {}) [e.type] && Q.get (o, "xử lý")) && l.apply (o, t),(l = u && o [u]) && l.apply && G (o) && (e.result = l.apply (o, t),! 1 === e.result && e.preventDefault ()); return e.type = d, r || e.isDefaultPrevented () || c._default &&! 1! == c._default.apply (p.pop (), t) ||! G (n) || u && m (n [d]) &&! x (n) && ((a = n [u]) && (n [u] = null), k.event.triggered = d, e.isPropagationStopped () && f.addEventListener (d, Ct), n [d] (), e.isPropagationStopped () && f.removeEventListener (d, Ct), k.event.triggered = void 0, a && (n [u] = a)), e.result}}, mô phỏng: function (e, t , n) {var r = k.extend (new k.Event, n, {type: e, isSimulation :! 0}); k.event.trigger (r, null, t)}}), k.fn. extend ({trigger: function (e, t) {return this.each (function () {k.event.trigger (e, t, this)})}, triggerHandler: function (e, t) {var n = this [0]; if (n) return k.event.trigger (e, t, n ,! 0)}}), y.f Focusin || k.each ({tập trung: "tập trung", làm mờ: "tập trung "}, function (n, r) {var i = function (e) {k.event.simulation (r, e.target, k.event.fix (e))}; k.event.special [r] = {setup: function () {var e = this.ownerDocument || this, t = Q.access (e, r); t || e.addEventListener (n, i ,! 0), Q.access (e, r, (t | | 0) +1)}, xé nát: function () {var e = this.ownerDocument || this, t = Q.access (e, r) -1; t? Q.access (e, r, t) :( e.removeEventListener (n, i ,! 0), Q.remove (e, r))}}}); var Et = C.location, kt = Date.now (), St = / \? /; k.parseXML = function (e) {var t; if (! e || "chuỗi"! = typeof e) return null; thử {t = (new C.DOMParser) .parseFromString (e, "text / xml ")} Catch (e) {t = void 0} return t &&! t.getElementsByTagName (" Parsererror "). length || k.error (" XML không hợp lệ: "+ e), t}; var Nt = / \ [\] $ /, Tại = / \ r? \ N / g, Dt = / ^ (?: Gửi | nút | hình ảnh | đặt lại | tệp) $ / i, jt = / ^ (?: Input | select | textarea | keygen) / i; hàm qt (n, e, r, i) {var t; if (Array.isArray (e)) k.each (e, function (e,t) {r || Nt.test (n)? i (n, t): qt (n + "[" + ("object" == typeof t && null! = t? e: "") + "]", t , r, i)}); other if (r || "object"! == w (e)) i (n, e); other for (t in e) qt (n + "[" + t + "]" , e [t], r, i)} k.param = function (e, t) {var n, r = [], i = function (e, t) {var n = m (t)? t () : t; r [r.length] = encodeURIComponent (e) + "=" + encodeURIComponent (null == n? "": n)}; if (null == e) return ""; if (Array.isArray ( e) || e.jquery &&! k.isPlainObject (e)) k.each (e, function () {i (this.name, this.value)}); khác cho (n in e) qt (n, e [n], t, i); return r.join ("&")}, k.fn.extend ({serialize: function () {return k.param (this.serializeArray ())}, serializeArray: function ( ) {return this.map (function () {var e = k.prop (this, "yếu tố"); return e? k.makeArray (e): this}). filter (function () {var e = this. gõ; trả lại this.name &&! k (this).là (": bị vô hiệu hóa") && jt.test (this.nodeName) &&! Dt.test (e) && (this.checked ||! pe.test (e))}). map (function (e, t) { var n = k (this) .val (); return null == n? null: Array.isArray (n)? k.map (n, function (e) {return {name: t.name, value: e. thay thế (Tại, "\ r \ n")}}): {name: t.name, value: n.replace (Tại, "\ r \ n")}}). get ()}}); var Lt = /% 20 / g, Ht = / #. * $ /, Ot = / ([? &]) _ = [^ &] * /, Pt = / ^ (. *?): [\ T] * ( [^ \ r \ n] *) $ / gm, Rt = / ^ (?: NHẬN | TRƯỚC) $ /, Mt = / ^ \ / \ //, Nó = {}, Wt = {}, $ t = "* /". concat ("*"), Ft = E.createEuity ("a"); hàm Bt (o) {hàm trả về (e, t) {"chuỗi"! = typeof e && (t = e, e = "*"); var n, r = 0, i = e.toLowerCase (). match (R) | | []; if (m (t)) while (n = i [r ++]) "+" = == n [0]? (n = n.slice (1) || "*", (o [n] = o [n] || []). unshift (t)) :( o [n] = o [n] || []). đẩy (t)}} hàm _t (t, i, o, a) {var s = {}, u = t === Wt; hàm l (e) {var r ;return s [e] =! 0, k.each (t [e] || [], hàm (e, t) {var n = t (i, o, a); trả về "chuỗi"! = typeof n | | u | | s [n]? u ?! (r = n): void 0: (i.dataTypes.unshift (n), l (n),! 1)}), r} trả lại l (i.dataTypes [0]) ||! S ["*"] && l ("*")} hàm zt (e, t) {var n, r, i = k.ajaxSinstall.flatOptions || {}; for (n in t ) void 0! == t [n] && ((i [n]? e: r || (r = {})) [n] = t [n]); trả về r && k.extend (! 0, e, r), e} Ft.href = Et.href, k.extend ({active: 0, lastModified: {}, etag: {}, ajaxSinstall: {url: Et.href, gõ: "GET", isLocal: / ^ (?: about | app | app-Storage |. + - extension | file | res | widget): $ /. test (Et.protatio), global :! 0, processData :! 0, async :! 0, contentType : "application / x-www-form-urlencoding; charset = UTF-8", chấp nhận: {"*": $ t, văn bản: "text / plain", html: "text / html", xml: "application / xml, văn bản / xml ", json:" application / json, text / javascript "},nội dung: {xml: / \ bxml \ b /, html: / \ bhtml /, json: / \ bjson \ b /}, answerFields: {xml: "responsXML", văn bản: "responsText", json: "responsJSON"} , trình chuyển đổi: {"* văn bản": Chuỗi, "văn bản html" :! 0, "văn bản json": JSON.parse, "văn bản xml": k.parseXML}, FlatOptions: {url :! 0, bối cảnh :! 0 }}, ajaxSetup: function (e, t) {return t? zt (zt (e, k.ajaxSinstall), t): zt (k.ajaxSinstall, e)}, ajaxPrefilter: Bt (It), ajaxTransport: Bt Wt), ajax: function (e, t) {"object" == typeof e && (t = e, e = void 0), t = t || {}; var c, f, p, n, d, r , h, g, i, o, v = k.ajaxSetup ({}, t), y = v.context || v, m = v.context && (y.nodeType || y.jquery)? k (y) : k.event, x = k.Deferred (), b = k.Callbacks ("bộ nhớ một lần"), w = v.statusCode || {}, a = {}, s = {}, u = "đã hủy" , T = {readyState: 0, getResponseHeader: function (e) {var t; if (h) {if (! N) {n = {}; while (t = Pt.exec (p)) n [t [1 ].toLowerCase () + ""] = (n [t [1] .toLowerCase () + ""] || []). concat (t [2])} t = n [e.toLowerCase () + ""] } return null == t? null: t.join (",")}, getAllResponseHeaders: function () {return h? p: null}, setRequestHeader: function (e, t) {return null == h && (e = s [e.toLowerCase ()] = s [e.toLowerCase ()] || e, a [e] = t), this}, overrideMimeType: function (e) {return null == h && (v.mimeType = e ), this}, statusCode: function (e) {var t; if (e) if (h) T.always (e [T.status]); other for (t in e) w [t] = [w [ t], e [t]]; return this}, abort: function (e) {var t = e || u; return c && c.abort (t), l (0, t), this}}; if (x .promise (T), v.url = ((e || v.url | | Et.href) + ""). thay thế (Mt, Et.protatio + "//"), v.type = t.method | | t.type | | v.method || v.type, v.dataTypes = (v.dataType || "*"). toLowerCase (). match (R) || [""], null == v. crossDomain) {r = E.createEuity ("a"); thử {r.href = v.url, r.href = r.href, v.crossDomain = Ft.protatio + "//" + Ft.host! = r.protatio + "//" + r.host} Catch (e) {v. crossDomain =! 0}} if (v.data && v. processData && "string"! = typeof v.data && (v.data = k.param (v.data, v.traditable)), _ t (Nó, v, t, T ), h) trả lại T; for (i in (g = k.event && v.global) && 0 == k.active ++ && k.event.trigger ("ajaxStart"), v.type = v.type.toUpperCase () , v.hasContent =! Rt.test (v.type), f = v.url.replace (Ht, ""), v.hasContent? v.data && v. processData && 0 === (v.contentType || "") .indexOf ("application / x-www-form-urlencoding") && (v.data = v.data.replace (Lt, "+")) :( o = v.url.slice (f.length), v .data && (v. processData || "chuỗi" == typeof v.data) && (f + = (St.test (f)? "&": "?") + v.data, xóa v.data),! 1 === v.bộ nhớ cache && (f = f.replace (Ot, "$ 1"), o = (St.test (f)? "&": "?") + "_ =" + kt +++ o), v.url = f + o), v.ifModified && (k.lastModified [f] && T.setRequestHeader ("If-Modified-Because", k.lastModified [f]), k.etag [f] && T.setRequestHeader ("If-none- Khớp ", k.etag [f])), (v.data && v.hasContent &&! 1! == v.contentType || t.contentType) && T.setRequestHeader (" Loại nội dung ", v.contentType), T.setRequestHead ("Chấp nhận", v.dataTypes [0] && v.ac accept [v.dataTypes [0]]? V.ac accept [v.dataTypes [0]] + ("*"! == v.dataTypes [0]? " , "+ $ t +"; q = 0,01 ":" "): v.ac chấp nhận [" * "]), v.headers) T.setRequestHeader (i, v.headers [i]); if (v.b BeforeSend && ( ! 1 === v.b BeforeSend.call (y, T, v) || h)) trả lại T.abort (); if (u = "abort", b.add (v.complete), T.xong (v.success), T.fail (v.error), c = _t (Wt, v, t, T)) {if (T. đãState = 1, g && m.trigger ("ajaxSend", [T, v ]), h) trả về T; v.async && 0 <v.timeout && (d = C.setTimeout (function () {T.abort ("timeout")}, v.timeout)); thử {h =! 1, c .send (a, l)} Catch (e) {if (h) throw e; l (-1, e)}} other l (-1, "No Transport"); hàm l (e, t, n, r) {var i, o, a, s, u, l = t; h || (h =! 0, d && C.clearTimeout (d), c = void 0, p = r || "", T. yetState = 0 <e? 4: 0, i = 200 <= e && e <300 || 304 === e, n && (s = chức năng (e, t, n) {var r, i, o, a, s = e .contents, u = e.dataTypes; while ("*" === u [0]) u.shift (), void 0 === r && (r = e.mimeType || t.getResponseHeader ("Loại nội dung ")); if (r) for (i in s) if (s [i] && s [i] .test (r)) {u.unshift (i); break} if (u [0] in n) o = u [0]; other {for (i in n) {if (! u [0] || e.converters [i + "" + u [0]]) {o = i;phá vỡ} a || (a = i)} o = o || a} if (o) return o! == u [0] && u.unshift (o), n [o]} (v, T, n) ), s = function (e, t, n, r) {var i, o, a, s, u, l = {}, c = e.dataTypes.slice (); if (c [1]) cho ( a trong e.converters) l [a.toLowerCase ()] = e.converters [a]; o = c.shift (); while (o) if (e.responseFields [o] && (n [e.responseFields [ o]] = t) ,! u && r && e.dataFilter && (t = e.dataFilter (t, e.dataType)), u = o, o = c.shift ()) if ("*" === o) o = u; khác if ("*"! == u && u! == o) {if (! (a = l [u + "" + o] | | l ["*" + o])) cho (i in l) if ((s = i.split ("")) [1] === o && (a = l [u + "" + s [0]] | | l ["*" + s [0]])) { ! 0 === a? A = l [i]:! 0! == l [i] && (o = s [0], c.unshift (s [1])); break} if (! 0! == a) if (a && e ["throws"]) t = a (t); khác thử {t = a (t)} Catch (e) {return {state: "Parsererror", lỗi: a? e: " Không có chuyển đổi từ "+ u +" thành "+ o}}} return {state:"thành công", dữ liệu: t}} (v, s, T, i), i? (v.ifModified && ((u = T.getResponseHeader ("Sửa đổi lần cuối")) && (k.lastModified [f] = u ), (u = T.getResponseHeader ("etag")) && (k.etag [f] = u)), 204 === e || "ĐẦU" === v.type? l = "nocontent": 304 === e? L = "chưa sửa đổi" :( l = s.state, o = s.data, i =! (A = s.error))) :( a = l ,! E && l || (l = "lỗi", e <0 && (e = 0))), T.status = e, T.statusText = (t || l) + "", i? x.resolveWith (y, [o, l, T] ): x.rejectWith (y, [T, l, a]), T.statusCode (w), w = void 0, g && m.trigger (i? "ajaxSuccess": "ajaxError", [T, v, i? o: a]), b.fireWith (y, [T, l]), g && (m.trigger ("ajaxComplete", [T, v]), - k.active || k.event.trigger (" ajaxStop ")))} return T}, getJSON: function (e, t, n) {return k.get (e, t, n," json ")}, getScript: function (e, t) {return k. nhận (e, void 0, t,"script")}}), k.each (["get", "post"], function (e, i) {k [i] = function (e, t, n, r) {return m (t) && (r = r || n, n = t, t = void 0), k.ajax (k.extend ({url: e, type: i, dataType: r, data: t, thành công: n}, k .isPlainObject (e) && e))}}), k._evalUrl = function (e, t) {return k.ajax ({url: e, gõ: "GET", dataType: "script", cache :! 0, async :! 1, global :! 1, converters: {"text script": function () {}}, dataFilter: function (e) {k.globalEval (e, t)}})}, k.fn.extend ({quấn ALL: function (e) {var t; trả lại [0] && (m (e) && (e = e.call (this [0])), t = k (e, this [0] .ownerDocument ) .eq (0) .clone (! 0), this [0] .parentNode && t.insertB Before (this [0]), t.map (function () {var e = this; while (e.firstEuityChild) e = e .firstEuityChild; return e}). append (this)), this}, quấnInner: function (n) {return m (n)? this.each (function (e) {k (this) .wrapInner (n.call ( này, e))}): này.mỗi (hàm () {var e = k (this), t = e.contents (); t.length? t.wrap ALL (n): e.append (n)})}, quấn: function (t) { var n = m (t); return this.each (function (e) {k (this) .wrap ALL (n? t.call (this, e): t)})}, yetrap: function (e) {return this .parent (e) .not ("body"). Each (function () {k (this) .replaceWith (this.childNodes)}), this}}), k.expr.pseudos.hidden = function (e ) {return! k.expr.pseudos.visible (e)}, k.expr.pseudos.visible = function (e) {return !! (e.offsetWidth || e.offsetHeight || e.getClientRects (). )}, k.ajaxSinstall.xhr = function () {thử {return new C.XMLHttpRequest} Catch (e) {}}; var Ut = {0: 200,1223: 204}, Xt = k.ajaxSinstall.xhr ( ); y.cors = !! Xt && "withCredentials" trong Xt, y.ajax = Xt = !! Xt, k.ajaxTransport (hàm (i) {var o, a; if (y.cors | | Xt &&! i. crossDomain) return {send: function (e, t) {var n, r = i.xhr (); if (r.open (i.type, i.url, i.async, i.username, i.password) , i.xhrFields) cho (n trong i.xhrFields) r [n] = i.xhrFields [n]; for (n trong i.mimeType && r.overrideMimeType && r.overrideMimeType (i.mimeType), i.crossDomain || e ["X-Requested-With"] ["X-Requested-With"] = "XMLHttpRequest"), e) r.setRequestHeader (n, e [n]); o = function (e) {return function () {o && (o = a = r.onload = r.onerror = r.onabort = r.ontimeout = r.onreadystatechange = null, "abort" === e? r.abort (): "error" === e? "number"! = typeof r.status ? t (0, "lỗi"): t (r.status, r.statusText): t (Ut [r.status] | | r.status, r.statusText, "văn bản"! == (r.responseType | | "văn bản") || "chuỗi"! = typeof r.responseText? {binary: r.response}: {text: r.responseText}, r.getAllResponseHeaders ()))}}, r.onload = o () , a = r.onerror = r.ontimeout = o ("error"), void 0! == r.onabort? r.onabort = a: r.onreadystatechange = function () {4 === r. yetState && C.setTimeout (function () {o && a ()})}, o = o ("hủy bỏ"); thử {r.send (i.hasContent && i.data || null)} Catch (e) {if (o) throw e}}, hủy bỏ: function () {o && o ()}}}), k.ajaxPrefilter (function (e) {e.crossDomain && (e.contents.script =! 1)}), k.ajaxSetup ({chấp nhận: {script: "text / javascript, application / javascript, application / ecmascript, application / x-ecmascript"}, nội dung: {script: / \ b (?: java | ecma) script \ b /}, trình chuyển đổi: {"text script ": function (e) {return k.globalEval (e), e}}}), k.ajaxPrefilter (" script ", function (e) {void 0 === e.cache && (e.cache =! 1 ), e.crossDomain && (e.type = "GET")}), k.ajaxTransport ("script", function (n) {var r, i; if (n.crossDomain || n.scriptAttrs) return {send: hàm (e, t) {r = k ("<script>"). attr (n.scriptAttrs || {}). prop ({charset: n.scriptCharset, src: n.url}).on ("lỗi tải", i = function (e) {r.remove (), i = null, e && t ("error" === e.type? 404: 200, e.type)}), E.head .appendChild (r [0])}, hủy bỏ: function () {i && i ()}}}); var Vt, Gt = [], Yt = / (=) \? (? = & | $) | \? \? /; k.ajaxSetup ({jsonp: "gọi lại", jsonpCallback: function () {var e = Gt.pop () || k.Exando + "_" + kt ++; trả lại [e] =! 0, e }}), k.ajaxPrefilter ("json jsonp", hàm (e, t, n) {var r, i, o, a =! 1! == e.jsonp && (Yt.test (e.url)? " url ":" chuỗi "== typeof e.data && 0 === (e.contentType ||" "). indexOf (" application / x-www-form-urlencoding ") && Yt.test (e.data) &&" data "); if (a ||" jsonp "=== e.dataTypes [0]) return r = e.jsonpCallback = m (e.jsonpCallback)? e.jsonpCallback (): e.jsonpCallback, a? e [a ] = e [a] .replace (Yt, "$ 1" + r):! 1! == e.jsonp && (e.url + = (St.test (e.url)? "&": "?") + e.jsonp + "=" + r), e.converters ["script json"] = function () {return o || k.error (r + "không được gọi là" ), o [0]}, e.dataTypes [0] = "json", i = C [r], C [r] = function () {o = argument}, n.always (function () {void 0 === i? K (C) .removeProp (r): C [r] = i, e [r] && (e.jsonpCallback = t.jsonpCallback, Gt.push (r)), o && m (i) && i ( o [0]), o = i = void 0}), "script"}), y.createHTMLDocument = ((Vt = E.im THỰCation.createHTMLDocument (""). body) .innerHTML = "<form> </ biểu mẫu> <form> </ form> ", 2 === Vt.childNodes.length), k.parseHTML = function (e, t, n) {return" chuỗi "! = typeof e? [] :(" boolean "== typeof t && (n = t, t =! 1), t || (y.createHTMLDocument? ((r = (t = E.im THỰCation.createHTMLDocument (" ")). createdEuity (" base ")). href = E.location.href, t.head.appendChild (r)): t = E), o =! n && [], (i = D.exec (e))? [t.createEuity (i [1])] :( i = we ([e], t, o), o && o.length && k (o) .remove (), k.merge ([], i.childNodes))); var r, i, o}, k.fn.load = function (e, t, n) {var r, i, o, a = this, s = e.indexOf (""); return-1 <s && (r = mt (e.slice (s)), e = e.slice (0, s)), m (t)? (n = t, t = void 0): t && "object" == typeof t && (i = "POST"), 0 <a.length && k.ajax ({url: e, gõ : i || "GET", dataType: "html", data: t}). xong (hàm (e) {o = argument, a.html (r? k ("<div>"). append (k. parseHTML (e)). find (r): e)}). always (n && function (e, t) {a.each (function () {n.apply (this, o || [e.responseText, t, e ])})}), this}, k.each (["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (e, t)fn [t] = function (e) {return this.on (t, e)}}), k.expr.pseudos.animated = function (t) {return k.grep (k.timers, function (e) { return t === e.elem}). length}, k.offset = {set Offerset: function (e, t, n) {var r, i, o, a, s, u, l = k.css (e , "vị trí"), c = k (e), f = {}; "tĩnh" === l && (e.style.poseition = "tương đối"), s = c.offset (), o = k.css (e, "trên cùng"), u = k.css (e, "trái"), ("tuyệt đối" === l | | "cố định" === l) && - 1 <(o + u) .indexOf ("tự động")? (a = (r = c.poseition ()). top, i = r.left) :( a = parseFloat (o) || 0, i = parseFloat (u) || 0), m (t) && (t = t.call (e, n, k.extend ({}, s))), null! = t.top && (f.top = t.top-s.top + a), null! = t.left && (f.left = t.left-s.left + i), "bằng cách sử dụng" trong t? t.USE.call (e, f): c.css (f)}}, k. fn.extend ({offset: function (t) {if (argument.length) return void 0 === t? this: this.each (function (e) {k.offset.set Offerset (this, t,e)}); var e, n, r = this [0]; return r? r.getClientRects (). length? (e = r.getBoundingClientRect (), n = r.ownerDocument.defaultView, {top: e. top + n.pageY Offerset, left: e.left + n.pageX Offerset}): {top: 0, left: 0}: void 0}, vị trí: function () {if (this [0]) {var e, t , n, r = this [0], i = {top: 0, left: 0}; if ("fixed" === k.css (r, "location")) t = r.getBoundingClientRect (); other {t = this.offset (), n = r.ownerDocument, e = r.offsetParent || n.documentEuity; while (e && (e === n.body || e === n.documentEuity) && "static "=== k.css (e," vị trí ")) e = e.parentNode; e && e! == r && 1 === e.nodeType && ((i = k (e) .offset ()). top + = k. css (e, "BorderTopWidth" ,! 0), i.left + = k.css (e, "BorderLeftWidth" ,! 0))} return {top: t.top-i.top-k.css (r, " marginTop ",! 0), left: t.left-i.left-k.css (r," marginLeft ",! 0)}}}, offsetParent: function () {trả lại cái này.map (function () {var e = this.offsetParent; while (e && "static" === k.css (e, "location")) e = e.offsetParent; return e | | tức là})}}), k.each ({scrollLeft: "pageX Offerset", scrollTop: "pageY Offerset"}, function (t, i) {var o = "pageY Offerset" === i; k.fn [t] = function (e) {return _ (này, hàm (e, t, n) {var r; if (x (e)? r = e: 9 === e.nodeType && (r = e.defaultView), void 0 === n) return r ? r [i]: e [t]; r? r.scrollTo (o? r.pageX Offerset: n, o? n: r.pageY Offerset): e [t] = n}, t, e, argument.length) }}), k.each (["top", "left"], function (e, n) {k.cssHooks [n] = ze (y.pixelPocation, function (e, t) {if (t) return t = _e (e, n), $ e.test (t)? k (e) .poseition () [n] + "px": t})}), k.each ({Chiều cao: "chiều cao", Width: "width"}, function (a, s) {k.each ({padding: "Inside" + a, content: s, "": "outs" + a}, function (r, o) {k. fn [o] = hàm (e,t) {var n = argument.length && (r || "boolean"! = typeof e), i = r || (! 0 === e ||! 0 === t? "lề": "đường viền" ); return _ (this, function (e, t, n) {var r; return x (e)? 0 === o.indexOf ("bên ngoài")? e ["bên trong" + a]: e.document .documentEuity ["client" + a]: 9 === e.nodeType? (r = e.documentEuity, Math.max (e.body ["scroll" + a], r ["scroll" + a], e .body ["offset" + a], r ["offset" + a], r ["client" + a])): void 0 === n? k.css (e, t, i): k. style (e, t, n, i)}, s, n? e: void 0, n)}})}), k.each ("tập trung làm mờ tiêu điểm tập trung thay đổi kích thước cuộn nhấp chuột dousclown mousedown mouseup chuột chuột di chuột chuột thay đổi chuột chọn gửi keydown keypress keyup bối cảnh ".split (" "), function (e, n) {k.fn [n] = function (e, t) {return 0 <argument.length? this.on (n, null, e, t): this.trigger (n)}}), k.fn.mở rộng ({hover: function (e, t) {return this.mouseenter (e) .mouseleave (t || e)}}), k.fn.extend ({bind: function (e, t, n) {return this.on (e, null, t, n)}, unbind: function (e, t) {return this.off (e, null, t)}, ủy nhiệm: function (e, t, n, r) {return this .on (t, e, n, r)}, undelegate: function (e, t, n) {return 1 === argument.length? this.off (e, "**"): this.off ( t, e | | "**", n)}}), k.proxy = function (e, t) {var n, r, i; if ("chuỗi" == typeof t && (n = e [t] , t = e, e = n), m (e)) return r = s.call (argument, 2), (i = function () {return e.apply (t || this, r.concat (s. gọi (đối số)))}). guide = e.guid = e.guid || k.guid ++, i}, k.keepReady = function (e) {e? k. yetWait ++: k. yet (! 0)} , k.isArray = Array.isArray, k.parseJSON = JSON.parse, k.nodeName = A, k.isFunction = m, k.isWindow = x, k.camelCase = V, k.type = w, k.now = Date.now, k.isNumeric = function (e) {var t = k.type (e); return ("number" === t || "chuỗi" === t) &&! isNaN (e-parseFloat (e))}, "function" == typeof định nghĩa && notify.amd && định nghĩa ("jquery", [], function () {return k}); var Qt = C.jQuery, Jt = C. $ ; return k.noConflict = function (e) {return C. $ === k && (C. $ = Jt), e && C.jQuery === k && (C.jQuery = Qt), k}, e || (C .jQuery = C. $ = k), k});